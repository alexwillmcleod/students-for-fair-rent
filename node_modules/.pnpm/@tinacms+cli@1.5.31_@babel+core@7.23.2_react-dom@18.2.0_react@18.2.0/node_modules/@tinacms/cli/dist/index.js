var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_clipanion8 = require("clipanion");

// package.json
var version = "1.5.31";

// src/next/commands/dev-command/index.ts
var import_clipanion2 = require("clipanion");
var import_fs_extra6 = __toESM(require("fs-extra"));
var import_path7 = __toESM(require("path"));
var import_chokidar = __toESM(require("chokidar"));
var import_graphql9 = require("@tinacms/graphql");

// src/next/config-manager.ts
var import_fs_extra = __toESM(require("fs-extra"));
var import_path = __toESM(require("path"));
var import_os = __toESM(require("os"));
var esbuild = __toESM(require("esbuild"));
var dotenv = __toESM(require("dotenv"));
var import_normalize_path = __toESM(require("normalize-path"));
var import_chalk2 = __toESM(require("chalk"));

// src/logger/index.ts
var import_chalk = __toESM(require("chalk"));

// src/logger/is-unicode-supported.ts
function isUnicodeSupported() {
  if (process.platform !== "win32") {
    return process.env.TERM !== "linux";
  }
  return Boolean(process.env.CI) || Boolean(process.env.WT_SESSION) || Boolean(process.env.TERMINUS_SUBLIME) || process.env.ConEmuTask === "{cmd::Cmder}" || process.env.TERM_PROGRAM === "Terminus-Sublime" || process.env.TERM_PROGRAM === "vscode" || process.env.TERM === "xterm-256color" || process.env.TERM === "alacritty" || process.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// src/logger/index.ts
var import_log4js = __toESM(require("log4js"));
var logger = import_log4js.default.getLogger();
import_log4js.default.configure({
  appenders: {
    out: { type: "stdout", layout: { type: "messagePassThrough" } }
  },
  categories: { default: { appenders: ["out"], level: "info" } }
});
logger.level = "info";
function ansiRegex() {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|");
  return new RegExp(pattern, "g");
}
var bar = "\u2502";
var strip = (str) => str.replace(ansiRegex(), "");
var note = (message = "", title = "") => {
  const lines = `
${message}
`.split("\n");
  const len = lines.reduce((sum, ln) => {
    ln = strip(ln);
    return ln.length > sum ? ln.length : sum;
  }, 0) + 2;
  const msg = lines.map(
    (ln) => `${import_chalk.default.gray(bar)}  ${import_chalk.default.white(ln)}${" ".repeat(
      len - strip(ln).length
    )}${import_chalk.default.gray(bar)}`
  ).join("\n");
  const underscoreLen = len - title.length - 1 > 0 ? len - title.length - 1 : 0;
  process.stdout.write(
    `${import_chalk.default.gray(bar)}
${import_chalk.default.green("\u25CB")}  ${import_chalk.default.reset(
      title
    )} ${import_chalk.default.gray("\u2500".repeat(underscoreLen) + "\u256E")}
${msg}
${import_chalk.default.gray(
      "\u251C" + "\u2500".repeat(len + 2) + "\u256F"
    )}
`
  );
};
var summary = (content2) => {
  const outString = [];
  let longestKey = 0;
  content2.items.forEach((item) => {
    item.subItems.forEach((subItem) => {
      if (subItem.key.length > longestKey) {
        longestKey = subItem.key.length;
      }
    });
  });
  content2.items.forEach((item) => {
    outString.push(`${item.emoji} ${import_chalk.default.cyan(item.heading)}`);
    item.subItems.forEach((subItem) => {
      const spaces = longestKey - subItem.key.length + 4;
      outString.push(
        `   ${subItem.key}:${[...Array(spaces)].join(" ")}${import_chalk.default.cyan(
          subItem.value
        )}`
      );
    });
    outString.push(``);
  });
  if (process.env.CI) {
    logger.info(JSON.stringify(content2, null, 2));
  } else {
    note(outString.join("\n"), content2.heading);
  }
};
var unicode = isUnicodeSupported();
var s = (c, fallback) => unicode ? c : fallback;
var S_STEP_ACTIVE = s("\u25C6", "*");
var S_STEP_CANCEL = s("\u25A0", "x");
var S_STEP_ERROR = s("\u25B2", "x");
var S_STEP_SUBMIT = s("\u25C7", "o");
var S_BAR_START = s("\u250C", "T");
var S_BAR = s("\u2502", "|");
var S_BAR_END = s("\u2514", "\u2014");
var S_RADIO_ACTIVE = s("\u25CF", ">");
var S_RADIO_INACTIVE = s("\u25CB", " ");
var S_CHECKBOX_ACTIVE = s("\u25FB", "[\u2022]");
var S_CHECKBOX_SELECTED = s("\u25FC", "[+]");
var S_CHECKBOX_INACTIVE = s("\u25FB", "[ ]");
var S_PASSWORD_MASK = s("\u25AA", "\u2022");
var S_BAR_H = s("\u2500", "-");
var S_CORNER_TOP_RIGHT = s("\u256E", "+");
var S_CONNECT_LEFT = s("\u251C", "+");
var S_CORNER_BOTTOM_RIGHT = s("\u256F", "+");
var S_INFO = s("\u25CF", "\u2022");
var S_SUCCESS = s("\u25C6", "*");
var S_WARN = s("\u25B2", "!");
var S_ERROR = s("\u25A0", "x");

// src/next/config-manager.ts
var TINA_FOLDER = "tina";
var LEGACY_TINA_FOLDER = ".tina";
var GENERATED_FOLDER = "__generated__";
var GRAPHQL_JSON_FILE = "_graphql.json";
var GRAPHQL_GQL_FILE = "schema.gql";
var SCHEMA_JSON_FILE = "_schema.json";
var LOOKUP_JSON_FILE = "_lookup.json";
var ConfigManager = class {
  constructor({
    rootPath = process.cwd(),
    tinaGraphQLVersion,
    legacyNoSDK
  }) {
    this.rootPath = (0, import_normalize_path.default)(rootPath);
    this.tinaGraphQLVersionFromCLI = tinaGraphQLVersion;
    this.legacyNoSDK = legacyNoSDK;
  }
  isUsingTs() {
    return [".ts", ".tsx"].includes(import_path.default.extname(this.tinaConfigFilePath));
  }
  hasSelfHostedConfig() {
    return !!this.selfHostedDatabaseFilePath;
  }
  hasSeparateContentRoot() {
    return this.rootPath !== this.contentRootPath;
  }
  shouldSkipSDK() {
    var _a;
    if (this.legacyNoSDK) {
      return this.legacyNoSDK;
    }
    return ((_a = this.config.client) == null ? void 0 : _a.skip) || false;
  }
  async processConfig() {
    this.tinaFolderPath = await this.getTinaFolderPath(this.rootPath);
    this.envFilePath = import_path.default.resolve(
      import_path.default.join(this.tinaFolderPath, "..", ".env")
    );
    dotenv.config({ path: this.envFilePath });
    this.tinaConfigFilePath = await this.getPathWithExtension(
      import_path.default.join(this.tinaFolderPath, "config")
    );
    if (!this.tinaConfigFilePath) {
      throw new Error(
        `Unable to find config file in ${this.tinaFolderPath}. Looking for a file named "config.{ts,tsx,js,jsx}"`
      );
    }
    this.selfHostedDatabaseFilePath = await this.getPathWithExtension(
      import_path.default.join(this.tinaFolderPath, "database")
    );
    this.generatedFolderPath = import_path.default.join(this.tinaFolderPath, GENERATED_FOLDER);
    this.generatedGraphQLGQLPath = import_path.default.join(
      this.generatedFolderPath,
      GRAPHQL_GQL_FILE
    );
    this.generatedGraphQLJSONPath = import_path.default.join(
      this.generatedFolderPath,
      GRAPHQL_JSON_FILE
    );
    this.generatedSchemaJSONPath = import_path.default.join(
      this.generatedFolderPath,
      SCHEMA_JSON_FILE
    );
    this.generatedLookupJSONPath = import_path.default.join(
      this.generatedFolderPath,
      LOOKUP_JSON_FILE
    );
    this.generatedQueriesFilePath = import_path.default.join(
      this.generatedFolderPath,
      "queries.gql"
    );
    this.generatedFragmentsFilePath = import_path.default.join(
      this.generatedFolderPath,
      "frags.gql"
    );
    this.generatedTypesTSFilePath = import_path.default.join(
      this.generatedFolderPath,
      "types.ts"
    );
    this.generatedTypesJSFilePath = import_path.default.join(
      this.generatedFolderPath,
      "types.js"
    );
    this.generatedTypesDFilePath = import_path.default.join(
      this.generatedFolderPath,
      "types.d.ts"
    );
    this.userQueriesAndFragmentsGlob = import_path.default.join(
      this.tinaFolderPath,
      "queries/**/*.{graphql,gql}"
    );
    this.generatedQueriesAndFragmentsGlob = import_path.default.join(
      this.generatedFolderPath,
      "*.{graphql,gql}"
    );
    this.generatedClientTSFilePath = import_path.default.join(
      this.generatedFolderPath,
      "client.ts"
    );
    this.generatedClientJSFilePath = import_path.default.join(
      this.generatedFolderPath,
      "client.js"
    );
    const clientExists = this.isUsingTs() ? await import_fs_extra.default.pathExists(this.generatedClientTSFilePath) : await import_fs_extra.default.pathExists(this.generatedClientJSFilePath);
    if (!clientExists) {
      const file = "export default ()=>({})\nexport const client = ()=>({})";
      if (this.isUsingTs()) {
        await import_fs_extra.default.outputFile(this.generatedClientTSFilePath, file);
      } else {
        await import_fs_extra.default.outputFile(this.generatedClientJSFilePath, file);
      }
    }
    const { config: config3, prebuildPath, watchList } = await this.loadConfigFile(
      this.generatedFolderPath,
      this.tinaConfigFilePath
    );
    this.watchList = watchList;
    this.config = config3;
    this.prebuildFilePath = prebuildPath;
    this.publicFolderPath = import_path.default.join(
      this.rootPath,
      this.config.build.publicFolder
    );
    this.outputFolderPath = import_path.default.join(
      this.publicFolderPath,
      this.config.build.outputFolder
    );
    this.outputHTMLFilePath = import_path.default.join(this.outputFolderPath, "index.html");
    this.outputGitignorePath = import_path.default.join(this.outputFolderPath, ".gitignore");
    const fullLocalContentPath = import_path.default.join(
      this.tinaFolderPath,
      this.config.localContentPath || ""
    );
    if (this.config.localContentPath) {
      const localContentPathExists = await import_fs_extra.default.pathExists(fullLocalContentPath);
      if (localContentPathExists) {
        logger.info(`Using separate content repo at ${fullLocalContentPath}`);
        this.contentRootPath = fullLocalContentPath;
      } else {
        logger.warn(
          `${import_chalk2.default.yellow("Warning:")} The localContentPath ${import_chalk2.default.cyan(
            fullLocalContentPath
          )} does not exist. Please create it or remove the localContentPath from your config file at ${import_chalk2.default.cyan(
            this.tinaConfigFilePath
          )}`
        );
      }
    }
    if (!this.contentRootPath) {
      this.contentRootPath = this.rootPath;
    }
    this.generatedFolderPathContentRepo = import_path.default.join(
      await this.getTinaFolderPath(this.contentRootPath),
      GENERATED_FOLDER
    );
    this.spaMainPath = require.resolve("@tinacms/app");
    this.spaRootPath = import_path.default.join(this.spaMainPath, "..", "..");
  }
  async getTinaFolderPath(rootPath) {
    const tinaFolderPath = import_path.default.join(rootPath, TINA_FOLDER);
    const tinaFolderExists = await import_fs_extra.default.pathExists(tinaFolderPath);
    if (tinaFolderExists) {
      this.isUsingLegacyFolder = false;
      return tinaFolderPath;
    }
    const legacyFolderPath = import_path.default.join(rootPath, LEGACY_TINA_FOLDER);
    const legacyFolderExists = await import_fs_extra.default.pathExists(legacyFolderPath);
    if (legacyFolderExists) {
      this.isUsingLegacyFolder = true;
      return legacyFolderPath;
    }
    throw new Error(
      `Unable to find Tina folder, if you're working in folder outside of the Tina config be sure to specify --rootPath`
    );
  }
  getTinaGraphQLVersion() {
    var _a, _b;
    if (this.tinaGraphQLVersionFromCLI) {
      return this.tinaGraphQLVersionFromCLI;
    }
    const generatedSchema = import_fs_extra.default.readJSONSync(this.generatedSchemaJSONPath);
    if (!generatedSchema || !(typeof (generatedSchema == null ? void 0 : generatedSchema.version) !== "undefined") || !(typeof ((_a = generatedSchema == null ? void 0 : generatedSchema.version) == null ? void 0 : _a.major) === "string") || !(typeof ((_b = generatedSchema == null ? void 0 : generatedSchema.version) == null ? void 0 : _b.minor) === "string")) {
      throw new Error(
        `Can not find Tina GraphQL version in ${this.generatedSchemaJSONPath}`
      );
    }
    return `${generatedSchema.version.major}.${generatedSchema.version.minor}`;
  }
  printGeneratedClientFilePath() {
    if (this.isUsingTs()) {
      return this.generatedClientTSFilePath.replace(`${this.rootPath}/`, "");
    }
    return this.generatedClientJSFilePath.replace(`${this.rootPath}/`, "");
  }
  printGeneratedTypesFilePath() {
    return this.generatedTypesTSFilePath.replace(`${this.rootPath}/`, "");
  }
  printoutputHTMLFilePath() {
    return this.outputHTMLFilePath.replace(`${this.publicFolderPath}/`, "");
  }
  printRelativePath(filename) {
    if (filename) {
      return filename.replace(/\\/g, "/").replace(`${this.rootPath}/`, "");
    }
    throw `No path provided to print`;
  }
  printPrebuildFilePath() {
    return this.prebuildFilePath.replace(/\\/g, "/").replace(`${this.rootPath}/${this.tinaFolderPath}/`, "");
  }
  printContentRelativePath(filename) {
    if (filename) {
      return filename.replace(/\\/g, "/").replace(`${this.contentRootPath}/`, "");
    }
    throw `No path provided to print`;
  }
  async getPathWithExtension(filepath) {
    const extensions = ["tsx", "ts", "jsx", "js"];
    let result;
    await Promise.all(
      extensions.map(async (ext) => {
        if (result) {
          return;
        }
        const filepathWithExtension = `${filepath}.${ext}`;
        const exists = await import_fs_extra.default.existsSync(filepathWithExtension);
        if (exists) {
          result = filepathWithExtension;
        }
      })
    );
    return result;
  }
  async loadDatabaseFile() {
    const tmpdir = import_path.default.join(import_os.default.tmpdir(), Date.now().toString());
    const outfile = import_path.default.join(tmpdir, "database.build.js");
    await esbuild.build({
      entryPoints: [this.selfHostedDatabaseFilePath],
      bundle: true,
      platform: "node",
      outfile,
      loader: loaders
    });
    const result = require(outfile);
    await import_fs_extra.default.removeSync(outfile);
    return result.default;
  }
  async loadConfigFile(generatedFolderPath, configFilePath) {
    const tmpdir = import_path.default.join(import_os.default.tmpdir(), Date.now().toString());
    const prebuild = import_path.default.join(this.generatedFolderPath, "config.prebuild.jsx");
    const outfile = import_path.default.join(tmpdir, "config.build.jsx");
    const outfile2 = import_path.default.join(tmpdir, "config.build.js");
    const tempTSConfigFile = import_path.default.join(tmpdir, "tsconfig.json");
    await import_fs_extra.default.outputFileSync(tempTSConfigFile, "{}");
    const result2 = await esbuild.build({
      entryPoints: [configFilePath],
      bundle: true,
      target: ["es2020"],
      platform: "browser",
      format: "esm",
      logLevel: "silent",
      packages: "external",
      ignoreAnnotations: true,
      outfile: prebuild,
      loader: loaders,
      metafile: true
    });
    const flattenedList = [];
    Object.keys(result2.metafile.inputs).forEach((key) => {
      if (key.includes("node_modules") || key.includes("__generated__")) {
        return;
      }
      flattenedList.push(key);
    });
    await esbuild.build({
      entryPoints: [configFilePath],
      bundle: true,
      target: ["es2020"],
      logLevel: "silent",
      platform: "node",
      outfile,
      loader: loaders
    });
    await esbuild.build({
      entryPoints: [outfile],
      bundle: true,
      logLevel: "silent",
      platform: "node",
      outfile: outfile2,
      loader: loaders
    });
    const result = require(outfile2);
    await import_fs_extra.default.removeSync(outfile);
    await import_fs_extra.default.removeSync(outfile2);
    return {
      config: result.default,
      prebuildPath: prebuild,
      watchList: flattenedList
    };
  }
};
var loaders = {
  ".aac": "file",
  ".css": "file",
  ".eot": "file",
  ".flac": "file",
  ".gif": "file",
  ".jpeg": "file",
  ".jpg": "file",
  ".json": "json",
  ".mp3": "file",
  ".mp4": "file",
  ".ogg": "file",
  ".otf": "file",
  ".png": "file",
  ".svg": "file",
  ".ttf": "file",
  ".wav": "file",
  ".webm": "file",
  ".webp": "file",
  ".woff": "file",
  ".woff2": "file",
  ".js": "jsx",
  ".jsx": "jsx",
  ".tsx": "tsx"
};

// src/next/commands/dev-command/html.ts
var errorHTML = `<style type="text/css">
#no-assets-placeholder body {
  font-family: sans-serif;
  font-size: 16px;
  line-height: 1.4;
  color: #333;
  background-color: #f5f5f5;
}
#no-assets-placeholder {
  max-width: 600px;
  margin: 0 auto;
  padding: 40px;
  text-align: center;
  background-color: #fff;
  box-shadow: 0px 0px 20px rgba(0, 0, 0, 0.1);
}
#no-assets-placeholder h1 {
  font-size: 24px;
  margin-bottom: 20px;
}
#no-assets-placeholder p {
  margin-bottom: 10px;
}
#no-assets-placeholder a {
  color: #0077cc;
  text-decoration: none;
}
#no-assets-placeholder a:hover {
  text-decoration: underline;
}
</style>
<div id="no-assets-placeholder">
<h1>Failed loading TinaCMS assets</h1>
<p>
  Your TinaCMS configuration may be misconfigured, and we could not load
  the assets for this page.
</p>
<p>
  Please visit <a href="https://tina.io/docs/tina-cloud/faq/#how-do-i-resolve-failed-loading-tinacms-assets-error">this doc</a> for help.
</p>
</div>
</div>`.trim().replace(/[\r\n\s]+/g, " ");
var devHTML = (port) => `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TinaCMS</title>
  </head>

  <!-- if development -->
  <script type="module">
    import RefreshRuntime from 'http://localhost:${port}/@react-refresh'
    RefreshRuntime.injectIntoGlobalHook(window)
    window.$RefreshReg$ = () => {}
    window.$RefreshSig$ = () => (type) => type
    window.__vite_plugin_react_preamble_installed__ = true
  <\/script>
  <script type="module" src="http://localhost:${port}/@vite/client"><\/script>
  <script>
  function handleLoadError() {
    // Assets have failed to load
    document.getElementById('root').innerHTML = '${errorHTML}';
  }
  <\/script>
  <script
    type="module"
    src="http://localhost:${port}/src/main.tsx"
    onerror="handleLoadError()"
  ><\/script>
  <body class="tina-tailwind">
    <div id="root"></div>
  </body>
</html>`;

// src/utils/theme.ts
var import_chalk3 = __toESM(require("chalk"));
var successText = import_chalk3.default.bold.green;
var focusText = import_chalk3.default.bold;
var dangerText = import_chalk3.default.bold.red;
var neutralText = import_chalk3.default.bold.cyan;
var linkText = import_chalk3.default.bold.cyan;
var labelText = import_chalk3.default.bold;
var cmdText = import_chalk3.default.inverse;
var indentedCmd = (str) => {
  return `  \u2503 ` + str;
};
var logText = import_chalk3.default.italic.gray;
var warnText = import_chalk3.default.yellowBright.bgBlack;
var titleText = import_chalk3.default.bgHex("d2f1f8").hex("ec4816");
var CONFIRMATION_TEXT = import_chalk3.default.dim("enter to confirm");

// src/next/commands/dev-command/server/index.ts
var import_vite3 = require("vite");

// src/next/vite/index.ts
var import_path3 = __toESM(require("path"));
var import_fs_extra2 = __toESM(require("fs-extra"));
var import_vite = require("vite");
var import_plugin_react = __toESM(require("@vitejs/plugin-react"));

// src/next/vite/tailwind.ts
var import_tailwindcss = __toESM(require("tailwindcss"));
var import_defaultTheme = __toESM(require("tailwindcss/defaultTheme.js"));
var import_typography = __toESM(require("@tailwindcss/typography"));
var import_aspect_ratio = __toESM(require("@tailwindcss/aspect-ratio"));
var import_path2 = __toESM(require("path"));
var tinaTailwind = (spaPath, prebuildFilePath) => {
  return {
    name: "vite-plugin-tina",
    config: (viteConfig) => {
      const plugins = [];
      const content2 = [
        import_path2.default.join(spaPath, "src/**/*.{vue,js,ts,jsx,tsx,svelte}"),
        prebuildFilePath,
        require.resolve("tinacms")
      ];
      const tw = (0, import_tailwindcss.default)({
        theme: {
          columns: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            "3xs": "256px",
            "2xs": "288px",
            xs: "320px",
            sm: "384px",
            md: "448px",
            lg: "512px",
            xl: "576px",
            "2xl": "672px",
            "3xl": "768px",
            "4xl": "896px",
            "5xl": "1024px",
            "6xl": "1152px",
            "7xl": "1280px"
          },
          spacing: {
            px: "1px",
            0: "0px",
            0.5: "2px",
            1: "4px",
            1.5: "6px",
            2: "8px",
            2.5: "10px",
            3: "12px",
            3.5: "14px",
            4: "16px",
            5: "20px",
            6: "24px",
            7: "28px",
            8: "32px",
            9: "36px",
            10: "40px",
            11: "44px",
            12: "48px",
            14: "56px",
            16: "64px",
            18: "72px",
            20: "80px",
            24: "96px",
            28: "114px",
            32: "128px",
            36: "144px",
            40: "160px",
            44: "176px",
            48: "192px",
            52: "208px",
            56: "224px",
            60: "240px",
            64: "256px",
            72: "288px",
            80: "320px",
            96: "384px"
          },
          borderRadius: {
            none: "0px",
            sm: "2px",
            DEFAULT: "4px",
            md: "6px",
            lg: "8px",
            xl: "12px",
            "2xl": "16px",
            "3xl": "24px",
            full: "9999px"
          },
          borderWidth: {
            DEFAULT: "1px",
            0: "0",
            2: "2px",
            3: "3px",
            4: "4px",
            6: "6px",
            8: "8px"
          },
          fontSize: {
            xs: ["13px", { lineHeight: "1.33" }],
            sm: ["14px", { lineHeight: "1.43" }],
            base: ["16px", { lineHeight: "1.5" }],
            md: ["16px", { lineHeight: "1.5" }],
            lg: ["18px", { lineHeight: "1.55" }],
            xl: ["20px", { lineHeight: "1.4" }],
            "2xl": ["24px", { lineHeight: "1.33" }],
            "3xl": ["30px", { lineHeight: "1.2" }],
            "4xl": ["36px", { lineHeight: "1.1" }],
            "5xl": ["48px", { lineHeight: "1" }],
            "6xl": ["60px", { lineHeight: "1" }],
            "7xl": ["72px", { lineHeight: "1" }],
            "8xl": ["96px", { lineHeight: "1" }],
            "9xl": ["128px", { lineHeight: "1" }]
          },
          opacity: {
            0: "0",
            5: ".05",
            7: ".07",
            10: ".1",
            15: ".15",
            20: ".2",
            25: ".25",
            30: ".3",
            40: ".4",
            50: ".5",
            60: ".6",
            70: ".7",
            75: ".75",
            80: ".8",
            90: ".9",
            100: "1"
          },
          zIndex: {
            "-1": "-1",
            base: "9000",
            panel: "9400",
            menu: "9800",
            chrome: "10200",
            overlay: "10600",
            modal: "10800",
            0: "0",
            10: "10",
            20: "20",
            30: "30",
            40: "40",
            25: "25",
            50: "50",
            75: "75",
            100: "100",
            auto: "auto"
          },
          extend: {
            scale: {
              97: ".97",
              103: "1.03"
            },
            transitionDuration: {
              0: "0ms",
              2e3: "2000ms"
            },
            boxShadow: {
              xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
              outline: "0 0 0 3px rgba(66, 153, 225, 0.5)"
            },
            colors: {
              blue: {
                50: "#DCEEFF",
                100: "#B4DBFF",
                200: "#85C5FE",
                300: "#4EABFE",
                400: "#2296fe",
                500: "#0084FF",
                600: "#0574e4",
                700: "#0D5DBD",
                800: "#144696",
                900: "#1D2C6C",
                1e3: "#241748"
              },
              gray: {
                50: "#F6F6F9",
                100: "#EDECF3",
                150: "#E6E3EF",
                200: "#E1DDEC",
                250: "#C9C5D5",
                300: "#b2adbe",
                400: "#918c9e",
                500: "#716c7f",
                600: "#565165",
                700: "#433e52",
                800: "#363145",
                900: "#252336",
                1e3: "#1c1b2e"
              },
              orange: {
                400: "#EB6337",
                500: "#EC4815",
                600: "#DC4419"
              }
            },
            fontFamily: {
              sans: ["Inter", ...import_defaultTheme.default.fontFamily.sans]
            },
            lineHeight: {
              3: "12px",
              4: "16px",
              5: "20px",
              6: "24px",
              7: "28px",
              8: "32px",
              9: "36px",
              10: "40px"
            },
            maxWidth: {
              form: "900px"
            },
            screens: {
              xs: "320px",
              sm: "560px",
              md: "720px",
              lg: "1030px"
            }
          }
        },
        content: content2,
        plugins: [(0, import_typography.default)({ className: "tina-prose" }), import_aspect_ratio.default]
      });
      plugins.push(tw);
      return {
        css: {
          postcss: {
            plugins
          }
        }
      };
    }
  };
};

// src/next/vite/index.ts
var import_normalize_path2 = __toESM(require("normalize-path"));
async function listFilesRecursively({
  directoryPath,
  config: config3,
  roothPath
}) {
  const fullDirectoryPath = import_path3.default.join(
    roothPath,
    config3.publicFolder,
    directoryPath
  );
  const exists = await import_fs_extra2.default.pathExists(fullDirectoryPath);
  if (!exists) {
    return { "0": [] };
  }
  const items = await import_fs_extra2.default.readdir(fullDirectoryPath);
  const staticMediaItems = [];
  for (const item of items) {
    const itemPath = import_path3.default.join(fullDirectoryPath, item);
    const stats = await import_fs_extra2.default.promises.lstat(itemPath);
    const staticMediaItem = {
      id: item,
      filename: item,
      type: stats.isDirectory() ? "dir" : "file",
      directory: `${directoryPath.replace(config3.mediaRoot, "")}`,
      src: `/${import_path3.default.join(directoryPath, item)}`,
      thumbnails: {
        "75x75": `/${import_path3.default.join(directoryPath, item)}`,
        "400x400": `/${import_path3.default.join(directoryPath, item)}`,
        "1000x1000": `/${import_path3.default.join(directoryPath, item)}`
      }
    };
    if (stats.isDirectory()) {
      staticMediaItem.children = await listFilesRecursively({
        directoryPath: import_path3.default.join(directoryPath, item),
        config: config3,
        roothPath
      });
    }
    staticMediaItems.push(staticMediaItem);
  }
  function chunkArrayIntoObject(array, chunkSize) {
    const result = {};
    for (let i = 0; i < array.length; i += chunkSize) {
      const chunkKey = `${i / chunkSize * 20}`;
      result[chunkKey] = array.slice(i, i + chunkSize);
    }
    return result;
  }
  return chunkArrayIntoObject(staticMediaItems, 20);
}
var createConfig = async ({
  configManager,
  database,
  apiURL,
  plugins = [],
  noWatch,
  rollupOptions
}) => {
  var _a, _b, _c, _d, _e, _f;
  const publicEnv = {};
  Object.keys(process.env).forEach((key) => {
    if (key.startsWith("TINA_PUBLIC_") || key.startsWith("NEXT_PUBLIC_") || key === "NODE_ENV" || key === "HEAD") {
      try {
        if (typeof process.env[key] === "string") {
          publicEnv[key] = process.env[key];
        } else {
          publicEnv[key] = JSON.stringify(process.env[key]);
        }
      } catch (error) {
        console.warn(
          `Could not stringify public env process.env.${key} env variable`
        );
        console.warn(error);
      }
    }
  });
  const staticMediaPath = import_path3.default.join(
    configManager.generatedFolderPath,
    "static-media.json"
  );
  if ((_b = (_a = configManager.config.media) == null ? void 0 : _a.tina) == null ? void 0 : _b.static) {
    const staticMedia = await listFilesRecursively({
      directoryPath: ((_c = configManager.config.media.tina) == null ? void 0 : _c.mediaRoot) || "",
      config: configManager.config.media.tina,
      roothPath: configManager.rootPath
    });
    await import_fs_extra2.default.outputFile(staticMediaPath, JSON.stringify(staticMedia, null, 2));
  } else {
    await import_fs_extra2.default.outputFile(staticMediaPath, `[]`);
  }
  const alias = {
    TINA_IMPORT: configManager.prebuildFilePath,
    SCHEMA_IMPORT: configManager.generatedGraphQLJSONPath,
    STATIC_MEDIA_IMPORT: staticMediaPath
  };
  if (configManager.shouldSkipSDK()) {
    alias["CLIENT_IMPORT"] = import_path3.default.join(
      configManager.spaRootPath,
      "src",
      "dummy-client.ts"
    );
  } else {
    alias["CLIENT_IMPORT"] = configManager.isUsingTs() ? configManager.generatedTypesTSFilePath : configManager.generatedTypesJSFilePath;
  }
  let basePath;
  if (configManager.config.build.basePath) {
    basePath = configManager.config.build.basePath;
  }
  const config3 = {
    root: configManager.spaRootPath,
    base: `/${basePath ? `${(0, import_normalize_path2.default)(basePath)}/` : ""}${(0, import_normalize_path2.default)(
      configManager.config.build.outputFolder
    )}/`,
    appType: "spa",
    resolve: {
      alias,
      dedupe: ["graphql", "tinacms", "react", "react-dom"]
    },
    define: {
      "process.env": `new Object(${JSON.stringify(publicEnv)})`,
      "process.platform": `"${process.platform}"`,
      __API_URL__: `"${apiURL}"`,
      __TOKEN__: `"${configManager.config.token}"`,
      __TINA_GRAPHQL_VERSION__: `"${configManager.getTinaGraphQLVersion()}"`
    },
    logLevel: "error",
    optimizeDeps: {
      force: true,
      include: ["react/jsx-runtime", "react/jsx-dev-runtime"]
    },
    server: {
      host: (_f = (_e = (_d = configManager.config) == null ? void 0 : _d.build) == null ? void 0 : _e.host) != null ? _f : false,
      watch: noWatch ? {
        ignored: ["**/*"]
      } : {
        ignored: [
          `${configManager.tinaFolderPath}/**/!(config.prebuild.jsx|_graphql.json)`
        ]
      },
      fs: {
        strict: false
      }
    },
    build: {
      sourcemap: false,
      outDir: configManager.outputFolderPath,
      emptyOutDir: true,
      rollupOptions
    },
    plugins: [
      (0, import_plugin_react.default)({
        babel: {
          compact: true
        }
      }),
      (0, import_vite.splitVendorChunkPlugin)(),
      tinaTailwind(configManager.spaRootPath, configManager.prebuildFilePath),
      ...plugins
    ]
  };
  return config3;
};

// src/next/vite/plugins.ts
var import_pluginutils = require("@rollup/pluginutils");
var import_fs = __toESM(require("fs"));
var import_vite2 = require("vite");
var import_esbuild = require("esbuild");
var import_path5 = __toESM(require("path"));
var import_body_parser = __toESM(require("body-parser"));
var import_cors = __toESM(require("cors"));
var import_graphql = require("@tinacms/graphql");

// src/next/commands/dev-command/server/media.ts
var import_fs_extra3 = __toESM(require("fs-extra"));
var import_path4 = __toESM(require("path"));
var import_busboy = __toESM(require("busboy"));
var createMediaRouter = (config3) => {
  const mediaFolder = import_path4.default.join(
    config3.rootPath,
    config3.publicFolder,
    config3.mediaRoot
  );
  const mediaModel = new MediaModel(config3);
  const handleList = async (req, res) => {
    const requestURL = new URL(req.url, config3.apiURL);
    const folder = requestURL.pathname.replace("/media/list/", "");
    const limit = requestURL.searchParams.get("limit");
    const cursor = requestURL.searchParams.get("cursor");
    const media = await mediaModel.listMedia({
      searchPath: folder,
      cursor,
      limit
    });
    res.end(JSON.stringify(media));
  };
  const handleDelete = async (req, res) => {
    const file = decodeURIComponent(req.url.slice("/media/".length));
    const didDelete = await mediaModel.deleteMedia({ searchPath: file });
    res.end(JSON.stringify(didDelete));
  };
  const handlePost = async function(req, res) {
    const bb = (0, import_busboy.default)({ headers: req.headers });
    bb.on("file", async (_name, file, _info) => {
      var _a;
      const fullPath = decodeURI((_a = req.url) == null ? void 0 : _a.slice("/media/upload/".length));
      const saveTo = import_path4.default.join(mediaFolder, ...fullPath.split("/"));
      await import_fs_extra3.default.ensureDir(import_path4.default.dirname(saveTo));
      file.pipe(import_fs_extra3.default.createWriteStream(saveTo));
    });
    bb.on("error", (error) => {
      res.statusCode = 500;
      if (error instanceof Error) {
        res.end(JSON.stringify({ message: error }));
      } else {
        res.end(JSON.stringify({ message: "Unknown error while uploading" }));
      }
    });
    bb.on("close", () => {
      res.statusCode = 200;
      res.end(JSON.stringify({ success: true }));
    });
    req.pipe(bb);
  };
  return { handleList, handleDelete, handlePost };
};
var parseMediaFolder = (str) => {
  let returnString = str;
  if (returnString.startsWith("/"))
    returnString = returnString.substr(1);
  if (returnString.endsWith("/"))
    returnString = returnString.substr(0, returnString.length - 1);
  return returnString;
};
var MediaModel = class {
  constructor({ rootPath, publicFolder, mediaRoot }) {
    this.rootPath = rootPath;
    this.mediaRoot = mediaRoot;
    this.publicFolder = publicFolder;
  }
  async listMedia(args) {
    try {
      const folderPath = (0, import_path4.join)(
        this.rootPath,
        this.publicFolder,
        this.mediaRoot,
        args.searchPath
      );
      const searchPath = parseMediaFolder(args.searchPath);
      if (!await import_fs_extra3.default.pathExists(folderPath)) {
        return {
          files: [],
          directories: []
        };
      }
      const filesStr = await import_fs_extra3.default.readdir(folderPath);
      const filesProm = filesStr.map(async (file) => {
        const filePath = (0, import_path4.join)(folderPath, file);
        const stat = await import_fs_extra3.default.stat(filePath);
        let src = `/${file}`;
        const isFile = stat.isFile();
        if (!isFile) {
          return {
            isFile,
            size: stat.size,
            src,
            filename: file
          };
        }
        if (searchPath) {
          src = `/${searchPath}${src}`;
        }
        if (this.mediaRoot) {
          src = `/${this.mediaRoot}${src}`;
        }
        return {
          isFile,
          size: stat.size,
          src,
          filename: file
        };
      });
      const offset = Number(args.cursor) || 0;
      const limit = Number(args.limit) || 20;
      const rawItems = await Promise.all(filesProm);
      const sortedItems = rawItems.sort((a, b) => {
        if (a.isFile && !b.isFile) {
          return 1;
        }
        if (!a.isFile && b.isFile) {
          return -1;
        }
        return 0;
      });
      const limitItems = sortedItems.slice(offset, offset + limit);
      const files = limitItems.filter((x) => x.isFile);
      const directories = limitItems.filter((x) => !x.isFile).map((x) => x.src);
      const cursor = rawItems.length > offset + limit ? String(offset + limit) : null;
      return {
        files,
        directories,
        cursor
      };
    } catch (error) {
      console.error(error);
      return {
        files: [],
        directories: [],
        error: error == null ? void 0 : error.toString()
      };
    }
  }
  async deleteMedia(args) {
    try {
      const file = (0, import_path4.join)(
        this.rootPath,
        this.publicFolder,
        this.mediaRoot,
        args.searchPath
      );
      await import_fs_extra3.default.stat(file);
      await import_fs_extra3.default.remove(file);
      return { ok: true };
    } catch (error) {
      console.error(error);
      return { ok: false, message: error == null ? void 0 : error.toString() };
    }
  }
};

// src/next/commands/dev-command/server/searchIndex.ts
var createSearchIndexRouter = ({
  config: config3,
  searchIndex
}) => {
  const put = async (req, res) => {
    const { docs } = req.body;
    const result = await searchIndex.PUT(docs);
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ result }));
  };
  const get = async (req, res) => {
    const requestURL = new URL(req.url, config3.apiURL);
    const query = requestURL.searchParams.get("q");
    const optionsParam = requestURL.searchParams.get("options");
    let options = {
      DOCUMENTS: false
    };
    if (optionsParam) {
      options = {
        ...options,
        ...JSON.parse(optionsParam)
      };
    }
    res.writeHead(200, { "Content-Type": "application/json" });
    if (query) {
      const result = await searchIndex.QUERY(JSON.parse(query), options);
      res.end(JSON.stringify(result));
    } else {
      res.end(JSON.stringify({ RESULT: [] }));
    }
  };
  const del = async (req, res) => {
    const requestURL = new URL(req.url, config3.apiURL);
    const docId = requestURL.pathname.split("/").filter(Boolean).slice(1).join("/");
    const result = await searchIndex.DELETE(docId);
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ result }));
  };
  return { del, get, put };
};

// src/next/vite/plugins.ts
var transformTsxPlugin = ({
  configManager: _configManager
}) => {
  const plug = {
    name: "transform-tsx",
    async transform(code, id) {
      const extName = import_path5.default.extname(id);
      if (extName.startsWith(".tsx") || extName.startsWith(".ts")) {
        const result = await (0, import_esbuild.transform)(code, { loader: "tsx" });
        return {
          code: result.code
        };
      }
    }
  };
  return plug;
};
var devServerEndPointsPlugin = ({
  configManager,
  apiURL,
  database,
  searchIndex
}) => {
  const plug = {
    name: "graphql-endpoints",
    configureServer(server) {
      server.middlewares.use((0, import_cors.default)());
      server.middlewares.use(import_body_parser.default.json({ limit: "5mb" }));
      server.middlewares.use(async (req, res, next) => {
        var _a;
        const mediaPaths = (_a = configManager.config.media) == null ? void 0 : _a.tina;
        const mediaRouter = createMediaRouter({
          rootPath: configManager.rootPath,
          apiURL,
          publicFolder: parseMediaFolder((mediaPaths == null ? void 0 : mediaPaths.publicFolder) || ""),
          mediaRoot: parseMediaFolder((mediaPaths == null ? void 0 : mediaPaths.mediaRoot) || "")
        });
        const searchIndexRouter = createSearchIndexRouter({
          config: { apiURL, searchPath: "searchIndex" },
          searchIndex
        });
        if (req.url.startsWith("/media/upload")) {
          await mediaRouter.handlePost(req, res);
          return;
        }
        if (req.url.startsWith("/media")) {
          if (req.method === "DELETE") {
            await mediaRouter.handleDelete(req, res);
            return;
          }
        }
        if (req.url.startsWith("/media/list")) {
          await mediaRouter.handleList(req, res);
          return;
        }
        if (req.url === "/altair") {
          res.end(
            JSON.stringify({
              status: "The GraphQL playground has moved to <your-dev-url>/index.html#/graphql"
            })
          );
          return;
        }
        if (req.url === "/graphql") {
          const { query, variables } = req.body;
          const result = await (0, import_graphql.resolve)({
            config: {
              useRelativeMedia: true
            },
            database,
            query,
            variables,
            verbose: false
          });
          res.end(JSON.stringify(result));
          return;
        }
        if (req.url.startsWith("/searchIndex")) {
          if (req.method === "POST") {
            await searchIndexRouter.put(req, res);
          } else if (req.method === "GET") {
            await searchIndexRouter.get(req, res);
          } else if (req.method === "DELETE") {
            await searchIndexRouter.del(req, res);
          }
          return;
        }
        next();
      });
    }
  };
  return plug;
};
function viteTransformExtension({
  exportAsDefault = true,
  svgrOptions,
  esbuildOptions,
  include = "**/*.svg",
  exclude
} = {}) {
  const filter = (0, import_pluginutils.createFilter)(include, exclude);
  return {
    name: "vite-plugin-svgr",
    async transform(code, id) {
      if (filter(id)) {
        const { transform: transform2 } = await Promise.resolve().then(() => __toESM(require("@svgr/core")));
        const svgCode = await import_fs.default.promises.readFile(
          id.replace(/\?.*$/, ""),
          "utf8"
        );
        const componentCode = await transform2(svgCode, svgrOptions, {
          filePath: id,
          caller: {
            previousExport: exportAsDefault ? null : code
          }
        });
        const res = await (0, import_vite2.transformWithEsbuild)(componentCode, id, {
          loader: "jsx",
          ...esbuildOptions
        });
        return {
          code: res.code,
          map: null
        };
      }
    }
  };
}

// src/next/commands/dev-command/server/index.ts
var createDevServer = async (configManager, database, searchIndex, apiURL, noWatch) => {
  const plugins = [
    transformTsxPlugin({ configManager }),
    devServerEndPointsPlugin({ apiURL, configManager, database, searchIndex }),
    viteTransformExtension()
  ];
  return (0, import_vite3.createServer)(
    await createConfig({
      configManager,
      database,
      apiURL,
      plugins,
      noWatch,
      rollupOptions: {
        input: configManager.spaMainPath
      }
    })
  );
};

// src/next/codegen/index.ts
var import_fs_extra4 = __toESM(require("fs-extra"));
var import_path6 = __toESM(require("path"));
var import_graphql6 = require("graphql");

// src/next/codegen/codegen/index.ts
var import_graphql5 = require("graphql");

// src/next/codegen/codegen/plugin.ts
var AddGeneratedClientFunc = (apiURL) => {
  return (_schema, _documents, _config, _info) => {
    return `
// TinaSDK generated code
import { createClient, TinaClient } from "tinacms/dist/client";

const generateRequester = (
  client: TinaClient,
  options?: { branch?: string }
) => {
  const requester: (
    doc: any,
    vars?: any,
    options?: { branch?: string },
    client
  ) => Promise<any> = async (doc, vars, options) => {
    let url = client.apiUrl
    if (options?.branch) {
      const index = client.apiUrl.lastIndexOf('/')
      url = client.apiUrl.substring(0, index + 1) + options.branch
    }
    const data = await client.request({
      query: doc,
      variables: vars,
      url,
    })

    return { data: data?.data, errors: data?.errors, query: doc, variables: vars || {} }
  }

  return requester
}

/**
 * @experimental this class can be used but may change in the future
 **/
export const ExperimentalGetTinaClient = () =>
  getSdk(
    generateRequester(
      createClient({
        url: "${apiURL}",
        queries,
      })
    )
  )

export const queries = (
  client: TinaClient,
  options?: {
    branch?: string
  }
) => {
  const requester = generateRequester(client, options)
  return getSdk(requester)
}
`;
  };
};
var AddGeneratedClient = (apiURL) => ({
  plugin: AddGeneratedClientFunc(apiURL)
});

// src/next/codegen/codegen/index.ts
var import_graphql_file_loader = require("@graphql-tools/graphql-file-loader");
var import_core = require("@graphql-codegen/core");
var import_load = require("@graphql-tools/load");
var import_typescript_operations = require("@graphql-codegen/typescript-operations");
var import_typescript = require("@graphql-codegen/typescript");

// src/next/codegen/codegen/sdkPlugin/index.ts
var import_graphql3 = require("graphql");
var import_graphql4 = require("graphql");

// src/next/codegen/codegen/sdkPlugin/visitor.ts
var import_visitor_plugin_common = require("@graphql-codegen/visitor-plugin-common");
var import_auto_bind = __toESM(require("auto-bind"));
var import_graphql2 = require("graphql");
var GenericSdkVisitor = class extends import_visitor_plugin_common.ClientSideBaseVisitor {
  constructor(schema, fragments, rawConfig) {
    super(schema, fragments, rawConfig, {
      usingObservableFrom: rawConfig.usingObservableFrom
    });
    this._operationsToInclude = [];
    (0, import_auto_bind.default)(this);
    if (this.config.usingObservableFrom) {
      this._additionalImports.push(this.config.usingObservableFrom);
    }
    if (this.config.documentMode !== import_visitor_plugin_common.DocumentMode.string) {
    }
  }
  buildOperation(node, documentVariableName, operationType, operationResultType, operationVariablesTypes) {
    if (node.name == null) {
      throw new Error(
        "Plugin 'generic-sdk' cannot generate SDK for unnamed operation.\n\n" + (0, import_graphql2.print)(node)
      );
    } else {
      this._operationsToInclude.push({
        node,
        documentVariableName,
        operationType,
        operationResultType: `{data: ${operationResultType}, errors?: { message: string, locations: { line: number, column: number }[], path: string[] }[], variables: ${operationVariablesTypes}, query: string}`,
        operationVariablesTypes
      });
    }
    return null;
  }
  get sdkContent() {
    const usingObservable = !!this.config.usingObservableFrom;
    const allPossibleActions = this._operationsToInclude.map((o) => {
      const optionalVariables = !o.node.variableDefinitions || o.node.variableDefinitions.length === 0 || o.node.variableDefinitions.every(
        (v) => v.type.kind !== import_graphql2.Kind.NON_NULL_TYPE || v.defaultValue
      );
      const returnType = usingObservable && o.operationType === "Subscription" ? "Observable" : "Promise";
      return `${o.node.name.value}(variables${optionalVariables ? "?" : ""}: ${o.operationVariablesTypes}, options?: C): ${returnType}<${o.operationResultType}> {
    return requester<${o.operationResultType}, ${o.operationVariablesTypes}>(${o.documentVariableName}, variables, options);
  }`;
    }).map((s2) => (0, import_visitor_plugin_common.indentMultiline)(s2, 2));
    return `export type Requester<C= {}> = <R, V>(doc: ${this.config.documentMode === import_visitor_plugin_common.DocumentMode.string ? "string" : "DocumentNode"}, vars?: V, options?: C) => ${usingObservable ? "Promise<R> & Observable<R>" : "Promise<R>"}
  export function getSdk<C>(requester: Requester<C>) {
    return {
  ${allPossibleActions.join(",\n")}
    };
  }
  export type Sdk = ReturnType<typeof getSdk>;`;
  }
};

// src/next/codegen/codegen/sdkPlugin/index.ts
var plugin = (schema, documents, config3) => {
  const allAst = (0, import_graphql4.concatAST)(
    documents.reduce((prev, v) => {
      return [...prev, v.document];
    }, [])
  );
  const allFragments = [
    ...allAst.definitions.filter(
      (d) => d.kind === import_graphql4.Kind.FRAGMENT_DEFINITION
    ).map((fragmentDef) => ({
      node: fragmentDef,
      name: fragmentDef.name.value,
      onType: fragmentDef.typeCondition.name.value,
      isExternal: false
    })),
    ...config3.externalFragments || []
  ];
  const visitor = new GenericSdkVisitor(schema, allFragments, config3);
  const visitorResult = (0, import_graphql3.visit)(allAst, { leave: visitor });
  return {
    content: [
      visitor.fragments,
      ...visitorResult.definitions.filter((t) => typeof t === "string"),
      visitor.sdkContent
    ].join("\n")
  };
};

// src/next/codegen/codegen/index.ts
var generateTypes = async (schema, queryPathGlob = process.cwd(), fragDocPath = process.cwd(), apiURL) => {
  let docs = [];
  let fragDocs = [];
  docs = await loadGraphQLDocuments(queryPathGlob);
  fragDocs = await loadGraphQLDocuments(fragDocPath);
  const res = await (0, import_core.codegen)({
    filename: process.cwd(),
    schema: (0, import_graphql5.parse)((0, import_graphql5.printSchema)(schema)),
    documents: [...docs, ...fragDocs],
    config: {},
    plugins: [
      { typescript: {} },
      { typescriptOperations: {} },
      {
        typescriptSdk: {}
      },
      { AddGeneratedClient: {} }
    ],
    pluginMap: {
      typescript: {
        plugin: import_typescript.plugin
      },
      typescriptOperations: {
        plugin: import_typescript_operations.plugin
      },
      typescriptSdk: {
        plugin
      },
      AddGeneratedClient: AddGeneratedClient(apiURL)
    }
  });
  return res;
};
var loadGraphQLDocuments = async (globPath) => {
  let result = [];
  try {
    result = await (0, import_load.loadDocuments)(globPath, {
      loaders: [new import_graphql_file_loader.GraphQLFileLoader()]
    });
  } catch (e) {
    if ((e.message || "").includes(
      "Unable to find any GraphQL type definitions for the following pointers:"
    )) {
    } else {
      throw e;
    }
  }
  return result;
};

// src/next/codegen/index.ts
var import_esbuild2 = require("esbuild");
var TINA_HOST = "content.tinajs.io";
var Codegen = class {
  constructor({
    configManager,
    port,
    queryDoc,
    fragDoc,
    isLocal,
    graphqlSchemaDoc,
    tinaSchema,
    lookup
  }) {
    this.isLocal = isLocal;
    this.graphqlSchemaDoc = graphqlSchemaDoc;
    this.configManager = configManager;
    this.port = port;
    this.schema = (0, import_graphql6.buildASTSchema)(graphqlSchemaDoc);
    this.tinaSchema = tinaSchema;
    this.queryDoc = queryDoc;
    this.fragDoc = fragDoc;
    this.lookup = lookup;
  }
  async writeConfigFile(fileName, data) {
    const filePath = import_path6.default.join(this.configManager.generatedFolderPath, fileName);
    await import_fs_extra4.default.ensureFile(filePath);
    await import_fs_extra4.default.outputFile(filePath, data);
    if (this.configManager.hasSeparateContentRoot()) {
      const filePath2 = import_path6.default.join(
        this.configManager.generatedFolderPathContentRepo,
        fileName
      );
      await import_fs_extra4.default.ensureFile(filePath2);
      await import_fs_extra4.default.outputFile(filePath2, data);
    }
  }
  async removeGeneratedFilesIfExists() {
    await unlinkIfExists(this.configManager.generatedClientJSFilePath);
    await unlinkIfExists(this.configManager.generatedTypesDFilePath);
    await unlinkIfExists(this.configManager.generatedTypesJSFilePath);
    await unlinkIfExists(this.configManager.generatedTypesTSFilePath);
    await unlinkIfExists(this.configManager.generatedClientTSFilePath);
    await unlinkIfExists(this.configManager.generatedQueriesFilePath);
    await unlinkIfExists(this.configManager.generatedFragmentsFilePath);
  }
  async execute() {
    await this.writeConfigFile(
      "_graphql.json",
      JSON.stringify(this.graphqlSchemaDoc)
    );
    await this.writeConfigFile(
      "_schema.json",
      JSON.stringify(this.tinaSchema.schema)
    );
    await this.writeConfigFile("_lookup.json", JSON.stringify(this.lookup));
    const { apiURL, localUrl, tinaCloudUrl } = this._createApiUrl();
    this.apiURL = apiURL;
    this.localUrl = localUrl;
    this.productionUrl = tinaCloudUrl;
    if (this.configManager.shouldSkipSDK()) {
      await this.removeGeneratedFilesIfExists();
      return apiURL;
    }
    await import_fs_extra4.default.outputFile(
      this.configManager.generatedQueriesFilePath,
      this.queryDoc
    );
    await import_fs_extra4.default.outputFile(
      this.configManager.generatedFragmentsFilePath,
      this.fragDoc
    );
    await maybeWarnFragmentSize(this.configManager.generatedFragmentsFilePath);
    const { clientString } = await this.genClient();
    const { codeString, schemaString } = await this.genTypes();
    await import_fs_extra4.default.outputFile(
      this.configManager.generatedGraphQLGQLPath,
      schemaString
    );
    if (this.configManager.isUsingTs()) {
      await import_fs_extra4.default.outputFile(
        this.configManager.generatedTypesTSFilePath,
        codeString
      );
      await import_fs_extra4.default.outputFile(
        this.configManager.generatedClientTSFilePath,
        clientString
      );
      await unlinkIfExists(this.configManager.generatedClientJSFilePath);
      await unlinkIfExists(this.configManager.generatedTypesDFilePath);
      await unlinkIfExists(this.configManager.generatedTypesJSFilePath);
    } else {
      await import_fs_extra4.default.outputFile(
        this.configManager.generatedTypesDFilePath,
        codeString
      );
      const jsCode = await (0, import_esbuild2.transform)(codeString, { loader: "ts" });
      await import_fs_extra4.default.outputFile(
        this.configManager.generatedTypesJSFilePath,
        jsCode.code
      );
      await import_fs_extra4.default.outputFile(
        this.configManager.generatedClientJSFilePath,
        clientString
      );
      await unlinkIfExists(this.configManager.generatedTypesTSFilePath);
      await unlinkIfExists(this.configManager.generatedClientTSFilePath);
    }
    return apiURL;
  }
  _createApiUrl() {
    var _a, _b, _c, _d;
    const branch = (_a = this.configManager.config) == null ? void 0 : _a.branch;
    const clientId = (_b = this.configManager.config) == null ? void 0 : _b.clientId;
    const token = (_c = this.configManager.config) == null ? void 0 : _c.token;
    const version2 = this.configManager.getTinaGraphQLVersion();
    const baseUrl = ((_d = this.configManager.config.tinaioConfig) == null ? void 0 : _d.contentApiUrlOverride) || `https://${TINA_HOST}`;
    if ((!branch || !clientId || !token) && !this.port && !this.configManager.config.contentApiUrlOverride) {
      const missing = [];
      if (!branch)
        missing.push("branch");
      if (!clientId)
        missing.push("clientId");
      if (!token)
        missing.push("token");
      throw new Error(
        `Client not configured properly. Missing ${missing.join(
          ", "
        )}. Please visit https://tina.io/docs/tina-cloud/connecting-site/ for more information`
      );
    }
    let localUrl = `http://localhost:${this.port}/graphql`;
    let tinaCloudUrl = `${baseUrl}/${version2}/content/${clientId}/github/${branch}`;
    let apiURL = this.isLocal ? `http://localhost:${this.port}/graphql` : `${baseUrl}/${version2}/content/${clientId}/github/${branch}`;
    if (this.configManager.config.contentApiUrlOverride) {
      apiURL = this.configManager.config.contentApiUrlOverride;
      localUrl = apiURL;
      tinaCloudUrl = apiURL;
    }
    return { apiURL, localUrl, tinaCloudUrl };
  }
  getApiURL() {
    if (!this.apiURL)
      throw new Error("apiURL not set. Please run execute() first");
    return this.apiURL;
  }
  async genClient() {
    var _a, _b, _c;
    const token = (_a = this.configManager.config) == null ? void 0 : _a.token;
    const errorPolicy = (_c = (_b = this.configManager.config) == null ? void 0 : _b.client) == null ? void 0 : _c.errorPolicy;
    const apiURL = this.getApiURL();
    const clientString = `import { createClient } from "tinacms/dist/client";
import { queries } from "./types";
export const client = createClient({ url: '${apiURL}', token: '${token}', queries, ${errorPolicy ? `errorPolicy: '${errorPolicy}'` : ""} });
export default client;
  `;
    return { apiURL, clientString };
  }
  async genTypes() {
    const typescriptTypes = await generateTypes(
      this.schema,
      this.configManager.userQueriesAndFragmentsGlob,
      this.configManager.generatedQueriesAndFragmentsGlob,
      this.getApiURL()
    );
    const codeString = `//@ts-nocheck
  // DO NOT MODIFY THIS FILE. This file is automatically generated by Tina
  export function gql(strings: TemplateStringsArray, ...args: string[]): string {
    let str = ''
    strings.forEach((string, i) => {
      str += string + (args[i] || '')
    })
    return str
  }
  ${typescriptTypes}
  `;
    const schemaString = `# DO NOT MODIFY THIS FILE. This file is automatically generated by Tina
${await (0, import_graphql6.printSchema)(this.schema)}
schema {
  query: Query
  mutation: Mutation
}
`;
    return { codeString, schemaString };
  }
};
var maybeWarnFragmentSize = async (filepath) => {
  if (await (await import_fs_extra4.default.stat(filepath)).size > 100 * 1024) {
    console.warn(
      "Warning: frags.gql is very large (>100kb). Consider setting the reference depth to 1 or 0. See code snippet below."
    );
    console.log(
      `const schema = defineSchema({
          client: {
              referenceDepth: 1,
          },
        // ...
    })`
    );
  }
};
var unlinkIfExists = async (filepath) => {
  if (await import_fs_extra4.default.existsSync(filepath)) {
    await import_fs_extra4.default.unlinkSync(filepath);
  }
};

// src/next/database.ts
var import_graphql7 = require("@tinacms/graphql");
var import_readable_stream = require("readable-stream");
var import_net = require("net");
var import_many_level = require("many-level");
var import_memory_level = require("memory-level");
var createDBServer = (port) => {
  const levelHost = new import_many_level.ManyLevelHost(
    new import_memory_level.MemoryLevel({
      valueEncoding: "json"
    })
  );
  const dbServer = (0, import_net.createServer)(function(socket) {
    return (0, import_readable_stream.pipeline)(socket, levelHost.createRpcStream(), socket, () => {
    });
  });
  dbServer.once("error", (err) => {
    if ((err == null ? void 0 : err.code) === "EADDRINUSE") {
      throw new Error(
        `Tina Dev server is already in use. Datalayer server is busy on port ${port}`
      );
    }
  });
  dbServer.listen(port);
};
async function createAndInitializeDatabase(configManager, datalayerPort, bridgeOverride) {
  let database;
  const bridge = bridgeOverride || new import_graphql7.FilesystemBridge(configManager.rootPath, configManager.contentRootPath);
  if (configManager.hasSelfHostedConfig() && configManager.config.contentApiUrlOverride) {
    database = await configManager.loadDatabaseFile();
    database.bridge = bridge;
  } else {
    if (configManager.hasSelfHostedConfig() && !configManager.config.contentApiUrlOverride) {
      logger.warn(
        `Found a database config file at ${configManager.printRelativePath(
          configManager.selfHostedDatabaseFilePath
        )} but there was no "contentApiUrlOverride" set. Falling back to built-in datalayer`
      );
    }
    const level = new import_graphql7.TinaLevelClient(datalayerPort);
    level.openConnection();
    database = (0, import_graphql7.createDatabase)({
      bridge,
      level,
      tinaDirectory: configManager.isUsingLegacyFolder ? LEGACY_TINA_FOLDER : TINA_FOLDER
    });
  }
  return database;
}

// src/next/commands/baseCommands.ts
var import_clipanion = require("clipanion");
var import_chalk4 = __toESM(require("chalk"));

// src/utils/start-subprocess.ts
var import_child_process = __toESM(require("child_process"));
var startSubprocess2 = async ({ command }) => {
  if (typeof command === "string") {
    const commands = command.split(" ");
    const firstCommand = commands[0];
    const args = commands.slice(1) || [];
    const ps = import_child_process.default.spawn(firstCommand, args, {
      stdio: "inherit",
      shell: true
    });
    ps.on("error", (code) => {
      logger.error(
        dangerText(
          `An error has occurred in the Next.js child process. Error message below`
        )
      );
      logger.error(`name: ${code.name}
message: ${code.message}

stack: ${code.stack || "No stack was provided"}`);
    });
    ps.on("close", (code) => {
      logger.info(`child process exited with code ${code}`);
      process.exit(code);
    });
    return ps;
  }
};

// src/utils/spinner.ts
var import_cli_spinner = require("cli-spinner");
async function localSpin({
  waitFor,
  text
}) {
  const spinner = new import_cli_spinner.Spinner({
    text: `${text} %s`,
    stream: process.stderr,
    onTick: function(msg) {
      this.clearLine(this.stream);
      this.stream.write(msg);
    }
  });
  spinner.setSpinnerString("\u280B\u2819\u2839\u2838\u283C\u2834\u2826\u2827\u2807\u280F");
  spinner.start();
  const res = await waitFor();
  spinner.stop();
  console.log("");
  return res;
}
function spin({
  waitFor,
  text
}) {
  if (process.env.CI) {
    console.log(text);
    return waitFor();
  } else {
    return localSpin({
      text,
      waitFor
    });
  }
}

// src/next/commands/baseCommands.ts
var import_graphql8 = require("@tinacms/graphql");
var import_fs_extra5 = __toESM(require("fs-extra"));
var BaseCommand = class extends import_clipanion.Command {
  constructor() {
    super(...arguments);
    this.experimentalDataLayer = import_clipanion.Option.Boolean("--experimentalData", {
      description: "DEPRECATED - Build the server with additional data querying capabilities"
    });
    this.isomorphicGitBridge = import_clipanion.Option.Boolean("--isomorphicGitBridge", {
      description: "DEPRECATED - Enable Isomorphic Git Bridge Implementation"
    });
    this.port = import_clipanion.Option.String("-p,--port", "4001", {
      description: "Specify a port to run the server on. (default 4001)"
    });
    this.datalayerPort = import_clipanion.Option.String("--datalayer-port", "9000", {
      description: "Specify a port to run the datalayer server on. (default 9000)"
    });
    this.subCommand = import_clipanion.Option.String("-c,--command", {
      description: "The sub-command to run"
    });
    this.rootPath = import_clipanion.Option.String("--rootPath", {
      description: "Specify the root directory to run the CLI from (defaults to current working directory)"
    });
    this.verbose = import_clipanion.Option.Boolean("-v,--verbose", false, {
      description: "increase verbosity of logged output"
    });
    this.noSDK = import_clipanion.Option.Boolean("--noSDK", false, {
      description: "DEPRECATED - This should now be set in the config at client.skip = true'. Don't generate the generated client SDK"
    });
    this.noTelemetry = import_clipanion.Option.Boolean("--noTelemetry", false, {
      description: "Disable anonymous telemetry that is collected"
    });
  }
  async startSubCommand() {
    let subProc;
    if (this.subCommand) {
      subProc = await startSubprocess2({ command: this.subCommand });
      logger.info(`Starting subprocess: ${import_chalk4.default.cyan(this.subCommand)}`);
    }
    function exitHandler(options, exitCode) {
      if (subProc) {
        subProc.kill();
      }
      process.exit();
    }
    process.on("exit", exitHandler);
    process.on("SIGINT", exitHandler);
    process.on("SIGUSR1", exitHandler);
    process.on("SIGUSR2", exitHandler);
    process.on("uncaughtException", (error) => {
      logger.error(`Uncaught exception ${error.name}`);
      console.error(error);
    });
  }
  logDeprecationWarnings() {
    if (this.isomorphicGitBridge) {
      logger.warn("--isomorphicGitBridge has been deprecated");
    }
    if (this.experimentalDataLayer) {
      logger.warn(
        "--experimentalDataLayer has been deprecated, the data layer is now built-in automatically"
      );
    }
    if (this.noSDK) {
      logger.warn(
        "--noSDK has been deprecated, and will be unsupported in a future release. This should be set in the config at client.skip = true"
      );
    }
  }
  async indexContentWithSpinner({
    database,
    graphQLSchema,
    tinaSchema,
    configManager,
    partialReindex,
    text
  }) {
    const textToUse = text || "Indexing local files";
    const warnings = [];
    await spin({
      waitFor: async () => {
        var _a, _b;
        const rootPath = configManager.rootPath;
        let sha;
        try {
          sha = await (0, import_graphql8.getSha)({ fs: import_fs_extra5.default, dir: rootPath });
        } catch (e) {
          if (partialReindex) {
            console.error(
              "Failed to get sha. NOTE: `--partial-reindex` only supported for git repositories"
            );
            throw e;
          }
        }
        const lastSha = await database.getMetadata("lastSha");
        const exists = lastSha && await (0, import_graphql8.shaExists)({ fs: import_fs_extra5.default, dir: rootPath, sha: lastSha });
        let res;
        if (partialReindex && lastSha && exists && sha) {
          const pathFilter = {};
          if (configManager.isUsingLegacyFolder) {
            pathFilter[".tina/__generated__/_schema.json"] = {};
          } else {
            pathFilter["tina/tina-lock.json"] = {};
          }
          for (const collection of tinaSchema.getCollections()) {
            pathFilter[collection.path] = {
              matches: ((_a = collection.match) == null ? void 0 : _a.exclude) || ((_b = collection.match) == null ? void 0 : _b.include) ? tinaSchema.getMatches({ collection }) : void 0
            };
          }
          const { added, modified, deleted } = await (0, import_graphql8.getChangedFiles)({
            fs: import_fs_extra5.default,
            dir: rootPath,
            from: lastSha,
            to: sha,
            pathFilter
          });
          const tinaPathUpdates = modified.filter(
            (path12) => path12.startsWith(".tina/__generated__/_schema.json") || path12.startsWith("tina/tina-lock.json")
          );
          if (tinaPathUpdates.length > 0) {
            res = await database.indexContent({
              graphQLSchema,
              tinaSchema
            });
          } else {
            if (added.length > 0 || modified.length > 0) {
              await database.indexContentByPaths([...added, ...modified]);
            }
            if (deleted.length > 0) {
              await database.deleteContentByPaths(deleted);
            }
          }
        } else {
          res = await database.indexContent({
            graphQLSchema,
            tinaSchema
          });
        }
        if (sha) {
          await database.setMetadata("lastSha", sha);
        }
        if (res == null ? void 0 : res.warnings) {
          warnings.push(...res.warnings);
        }
      },
      text: textToUse
    });
    if (warnings.length > 0) {
      logger.warn(`Indexing completed with ${warnings.length} warning(s)`);
      warnings.forEach((warning) => {
        logger.warn(warnText(`${warning}`));
      });
    }
  }
};

// src/next/commands/dev-command/index.ts
var import_search = require("@tinacms/search");
var DevCommand = class extends BaseCommand {
  constructor() {
    super(...arguments);
    this.watchFolders = import_clipanion2.Option.String("-w,--watchFolders", {
      description: "DEPRECATED - a list of folders (relative to where this is being run) that the cli will watch for changes"
    });
    this.noWatch = import_clipanion2.Option.Boolean("--noWatch", false, {
      description: "Don't regenerate config on file changes"
    });
    this.outputSearchIndexPath = import_clipanion2.Option.String("--outputSearchIndexPath", {
      description: "Path to write the search index to"
    });
  }
  async catch(error) {
    logger.error("Error occured during tinacms dev");
    console.error(error);
    process.exit(1);
  }
  logDeprecationWarnings() {
    super.logDeprecationWarnings();
    if (this.watchFolders) {
      logger.warn(
        "--watchFolders has been deprecated, imports from your Tina config file will be watched automatically. If you still need it please open a ticket at https://github.com/tinacms/tinacms/issues"
      );
    }
  }
  async execute() {
    var _a, _b, _c, _d, _e, _f;
    const configManager = new ConfigManager({
      rootPath: this.rootPath,
      legacyNoSDK: this.noSDK
    });
    logger.info("Starting Tina Dev Server");
    this.logDeprecationWarnings();
    createDBServer(Number(this.datalayerPort));
    let database = null;
    const setup = async ({ firstTime }) => {
      try {
        await configManager.processConfig();
        if (firstTime) {
          database = await createAndInitializeDatabase(
            configManager,
            Number(this.datalayerPort)
          );
        } else {
          database.clearCache();
        }
        const { tinaSchema: tinaSchema2, graphQLSchema: graphQLSchema2, lookup, queryDoc, fragDoc } = await (0, import_graphql9.buildSchema)(configManager.config);
        const codegen2 = new Codegen({
          isLocal: true,
          configManager,
          port: Number(this.port),
          queryDoc,
          fragDoc,
          graphqlSchemaDoc: graphQLSchema2,
          tinaSchema: tinaSchema2,
          lookup
        });
        const apiURL2 = await codegen2.execute();
        if (!configManager.isUsingLegacyFolder) {
          delete require.cache[configManager.generatedSchemaJSONPath];
          delete require.cache[configManager.generatedLookupJSONPath];
          delete require.cache[configManager.generatedGraphQLJSONPath];
          const schemaObject = require(configManager.generatedSchemaJSONPath);
          const lookupObject = require(configManager.generatedLookupJSONPath);
          const graphqlSchemaObject = require(configManager.generatedGraphQLJSONPath);
          const tinaLockFilename = "tina-lock.json";
          const tinaLockContent = JSON.stringify({
            schema: schemaObject,
            lookup: lookupObject,
            graphql: graphqlSchemaObject
          });
          import_fs_extra6.default.writeFileSync(
            import_path7.default.join(configManager.tinaFolderPath, tinaLockFilename),
            tinaLockContent
          );
          if (configManager.hasSeparateContentRoot()) {
            const rootPath = await configManager.getTinaFolderPath(
              configManager.contentRootPath
            );
            const filePath = import_path7.default.join(rootPath, tinaLockFilename);
            await import_fs_extra6.default.ensureFile(filePath);
            await import_fs_extra6.default.outputFile(filePath, tinaLockContent);
          }
        }
        if (!this.noWatch) {
          this.watchQueries(configManager, async () => await codegen2.execute());
        }
        await this.indexContentWithSpinner({
          database,
          graphQLSchema: graphQLSchema2,
          tinaSchema: tinaSchema2,
          configManager
        });
        if (!firstTime) {
          logger.error("Re-index complete");
        }
        return { apiURL: apiURL2, database, graphQLSchema: graphQLSchema2, tinaSchema: tinaSchema2 };
      } catch (e) {
        logger.error(`

${dangerText(e.message)}
`);
        if (this.verbose) {
          console.error(e);
        }
        if (firstTime) {
          logger.error(
            warnText(
              "Unable to start dev server, please fix your Tina config / resolve any errors above and try again"
            )
          );
          process.exit(1);
        } else {
          logger.error(warnText("Dev server has not been restarted"));
        }
      }
    };
    const { apiURL, graphQLSchema, tinaSchema } = await setup({
      firstTime: true
    });
    await import_fs_extra6.default.outputFile(configManager.outputHTMLFilePath, devHTML(this.port));
    await import_fs_extra6.default.outputFile(
      configManager.outputGitignorePath,
      "index.html\nassets/"
    );
    const searchIndexClient = new import_search.LocalSearchIndexClient({
      stopwordLanguages: (_b = (_a = configManager.config.search) == null ? void 0 : _a.tina) == null ? void 0 : _b.stopwordLanguages,
      tokenSplitRegex: (_d = (_c = configManager.config.search) == null ? void 0 : _c.tina) == null ? void 0 : _d.tokenSplitRegex
    });
    await searchIndexClient.onStartIndexing();
    const server = await createDevServer(
      configManager,
      database,
      searchIndexClient.searchIndex,
      apiURL,
      this.noWatch
    );
    await server.listen(Number(this.port));
    const searchIndexer = new import_search.SearchIndexer({
      batchSize: ((_e = configManager.config.search) == null ? void 0 : _e.indexBatchSize) || 100,
      bridge: new import_graphql9.FilesystemBridge(
        configManager.rootPath,
        configManager.contentRootPath
      ),
      schema: tinaSchema,
      client: searchIndexClient,
      textIndexLength: ((_f = configManager.config.search) == null ? void 0 : _f.maxSearchIndexFieldLength) || 100
    });
    if (configManager.config.search) {
      await spin({
        waitFor: async () => {
          await searchIndexer.indexAllContent();
        },
        text: "Building search index"
      });
      if (this.outputSearchIndexPath) {
        await searchIndexClient.export(this.outputSearchIndexPath);
      }
    }
    if (!this.noWatch) {
      this.watchContentFiles(
        configManager,
        database,
        configManager.config.search && searchIndexer
      );
      import_chokidar.default.watch(configManager.watchList).on("change", async () => {
        logger.info(`Tina config change detected, rebuilding`);
        await setup({ firstTime: false });
        server.ws.send({ type: "full-reload", path: "*" });
      });
    }
    const subItems = [];
    if (configManager.hasSeparateContentRoot()) {
      subItems.push({
        key: "Content repo",
        value: configManager.contentRootPath
      });
    }
    const summaryItems = [
      {
        emoji: "\u{1F999}",
        heading: "Tina Config",
        subItems: [
          {
            key: "CMS",
            value: `<your-dev-server-url>/${configManager.printoutputHTMLFilePath()}`
          },
          {
            key: "API playground",
            value: `<your-dev-server-url>/${configManager.printoutputHTMLFilePath()}#/graphql`
          },
          {
            key: "API url",
            value: apiURL
          },
          ...subItems
        ]
      }
    ];
    if (!configManager.shouldSkipSDK()) {
      summaryItems.push({
        emoji: "\u{1F916}",
        heading: "Auto-generated files",
        subItems: [
          {
            key: "GraphQL Client",
            value: configManager.printGeneratedClientFilePath()
          },
          {
            key: "Typescript Types",
            value: configManager.printGeneratedTypesFilePath()
          }
        ]
      });
    }
    summary({
      heading: "Tina Dev Server is running...",
      items: [
        ...summaryItems
      ]
    });
    await this.startSubCommand();
  }
  watchContentFiles(configManager, database, searchIndexer) {
    const collectionContentFiles = [];
    configManager.config.schema.collections.forEach((collection) => {
      const collectionGlob = `${import_path7.default.join(
        configManager.contentRootPath,
        collection.path
      )}/**/*.${collection.format || "md"}`;
      collectionContentFiles.push(collectionGlob);
    });
    let ready = false;
    import_chokidar.default.watch(collectionContentFiles).on("ready", () => {
      ready = true;
    }).on("add", async (addedFile) => {
      if (!ready) {
        return;
      }
      const pathFromRoot = configManager.printContentRelativePath(addedFile);
      await database.indexContentByPaths([pathFromRoot]).catch(console.error);
      if (searchIndexer) {
        await searchIndexer.indexContentByPaths([pathFromRoot]).catch(console.error);
      }
    }).on("change", async (changedFile) => {
      const pathFromRoot = configManager.printContentRelativePath(changedFile);
      await database.indexContentByPaths([pathFromRoot]).catch(console.error);
      if (searchIndexer) {
        await searchIndexer.indexContentByPaths([pathFromRoot]).catch(console.error);
      }
    }).on("unlink", async (removedFile) => {
      const pathFromRoot = configManager.printContentRelativePath(removedFile);
      await database.deleteContentByPaths([pathFromRoot]).catch(console.error);
      if (searchIndexer) {
        await searchIndexer.deleteIndexContent([pathFromRoot]).catch(console.error);
      }
    });
  }
  watchQueries(configManager, callback) {
    let ready = false;
    import_chokidar.default.watch(configManager.userQueriesAndFragmentsGlob).on("ready", () => {
      ready = true;
    }).on("add", async (addedFile) => {
      await callback();
    }).on("change", async (changedFile) => {
      await callback();
    }).on("unlink", async (removedFile) => {
      await callback();
    });
  }
};
DevCommand.paths = [["dev"], ["server:start"]];
DevCommand.usage = import_clipanion2.Command.Usage({
  category: `Commands`,
  description: `Builds Tina and starts the dev server`,
  examples: [
    [`A basic example`, `$0 dev`],
    [`A second example`, `$0 dev --rootPath`]
  ]
});

// src/next/commands/build-command/index.ts
var import_node_fetch2 = __toESM(require("node-fetch"));
var import_clipanion3 = require("clipanion");
var import_progress2 = __toESM(require("progress"));
var import_fs_extra7 = __toESM(require("fs-extra"));
var import_graphql10 = require("@tinacms/graphql");

// src/next/commands/build-command/server.ts
var import_vite5 = require("vite");
var buildProductionSpa = async (configManager, database, apiURL) => {
  const publicEnv = {};
  Object.keys(process.env).forEach((key) => {
    if (key.startsWith("TINA_PUBLIC_") || key.startsWith("NEXT_PUBLIC_") || key === "NODE_ENV" || key === "HEAD") {
      try {
        if (typeof process.env[key] === "string") {
          publicEnv[key] = process.env[key];
        } else {
          publicEnv[key] = JSON.stringify(process.env[key]);
        }
      } catch (error) {
        console.warn(
          `Could not stringify public env process.env.${key} env variable`
        );
        console.warn(error);
      }
    }
  });
  const config3 = await createConfig({
    plugins: [transformTsxPlugin({ configManager }), viteTransformExtension()],
    configManager,
    database,
    apiURL,
    noWatch: true
  });
  return (0, import_vite5.build)(config3);
};

// src/next/commands/build-command/index.ts
var import_schema_tools2 = require("@tinacms/schema-tools");
var import_graphql11 = require("graphql");
var import_core2 = require("@graphql-inspector/core");

// src/next/commands/build-command/waitForDB.ts
var import_progress = __toESM(require("progress"));
var import_schema_tools = require("@tinacms/schema-tools");
var import_node_fetch = __toESM(require("node-fetch"));

// src/utils/sleep.ts
function timeout(ms) {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
}
async function sleepAndCallFunc({
  fn,
  ms
}) {
  await timeout(ms);
  const res = await fn();
  return res;
}

// src/next/commands/build-command/waitForDB.ts
var POLLING_INTERVAL = 5e3;
var STATUS_INPROGRESS = "inprogress";
var STATUS_COMPLETE = "complete";
var STATUS_FAILED = "failed";
var IndexFailedError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "IndexFailedError";
  }
};
var waitForDB = async (config3, apiUrl, verbose) => {
  const token = config3.token;
  const { clientId, branch, isLocalClient, host } = (0, import_schema_tools.parseURL)(apiUrl);
  if (isLocalClient || !host || !clientId || !branch) {
    if (verbose) {
      logger.info(logText("Not using Tina Cloud, skipping DB check"));
    }
    return;
  }
  const bar2 = new import_progress.default(
    "Checking indexing process in Tina Cloud... :prog",
    1
  );
  const pollForStatus = async () => {
    try {
      if (verbose) {
        logger.info(logText("Polling for status..."));
      }
      const headers = new import_node_fetch.Headers();
      headers.append("Content-Type", "application/json");
      if (token) {
        headers.append("X-API-KEY", token);
      }
      const response = await (0, import_node_fetch.default)(
        `https://${host}/db/${clientId}/status/${branch}`,
        {
          method: "GET",
          headers,
          cache: "no-cache"
        }
      );
      const { status, error } = await response.json();
      const statusMessage = `Indexing status: '${status}'`;
      if (status === STATUS_COMPLETE) {
        bar2.tick({
          prog: "\u2705"
        });
      } else if (status === STATUS_INPROGRESS) {
        if (verbose) {
          logger.info(logText(`${statusMessage}, trying again in 5 seconds`));
        }
        await sleepAndCallFunc({ fn: pollForStatus, ms: POLLING_INTERVAL });
      } else if (status === STATUS_FAILED) {
        throw new IndexFailedError(
          `Attempting to index but responded with status 'failed'. To retry the indexing process, click the "Reindex" button for '${branch}' in the Tina Cloud configuration for this project.  ${error}`
        );
      } else {
        throw new IndexFailedError(
          `Attempting to index but responded with status 'unknown'. To retry the indexing process, click the "Reindex" button for '${branch}' in the Tina Cloud configuration for this project.  ${error}`
        );
      }
    } catch (e) {
      if (e instanceof IndexFailedError) {
        bar2.tick({
          prog: "\u274C"
        });
        throw e;
      } else {
        throw new Error(
          `Unable to query DB for indexing status, encountered error: ${e.message}`
        );
      }
    }
  };
  await spin({
    text: "Checking indexing process in Tina Cloud...",
    waitFor: pollForStatus
  });
};

// src/next/commands/build-command/index.ts
var import_search2 = require("@tinacms/search");
var BuildCommand = class extends BaseCommand {
  constructor() {
    super(...arguments);
    this.localOption = import_clipanion3.Option.Boolean("--local", {
      description: "Starts local Graphql server and builds the local client instead of production client"
    });
    this.skipIndexing = import_clipanion3.Option.Boolean("--skip-indexing", false, {
      description: "Skips indexing the content. This can be used for building the site without indexing the content  (defaults to false)"
    });
    this.partialReindex = import_clipanion3.Option.Boolean("--partial-reindex", false, {
      description: "Re-indexes only the content that has changed since the last build (defaults to false). Not currently supported for separate content repos."
    });
    this.tinaGraphQLVersion = import_clipanion3.Option.String("--tina-graphql-version", {
      description: "Specify the version of @tinacms/graphql to use (defaults to latest)"
    });
    this.skipCloudChecks = import_clipanion3.Option.Boolean("--skip-cloud-checks", false, {
      description: "Skips checking the provided cloud config."
    });
    this.skipSearchIndex = import_clipanion3.Option.Boolean("--skip-search-index", false, {
      description: "Skip indexing the site for search"
    });
  }
  async catch(error) {
    console.error(error);
    process.exit(1);
  }
  async execute() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
    logger.info("Starting Tina build");
    this.logDeprecationWarnings();
    const configManager = new ConfigManager({
      rootPath: this.rootPath,
      tinaGraphQLVersion: this.tinaGraphQLVersion,
      legacyNoSDK: this.noSDK
    });
    try {
      await configManager.processConfig();
    } catch (e) {
      logger.error(`
${dangerText(e.message)}`);
      logger.error(
        dangerText("Unable to build, please fix your Tina config and try again")
      );
      process.exit(1);
    }
    let server;
    createDBServer(Number(this.datalayerPort));
    const database = await createAndInitializeDatabase(
      configManager,
      Number(this.datalayerPort)
    );
    const { queryDoc, fragDoc, graphQLSchema, tinaSchema, lookup } = await (0, import_graphql10.buildSchema)(configManager.config);
    const codegen2 = new Codegen({
      configManager,
      port: this.localOption ? Number(this.port) : void 0,
      isLocal: this.localOption,
      queryDoc,
      fragDoc,
      graphqlSchemaDoc: graphQLSchema,
      tinaSchema,
      lookup
    });
    const apiURL = await codegen2.execute();
    if ((configManager.hasSelfHostedConfig() || this.localOption) && !this.skipIndexing) {
      const text = this.localOption ? void 0 : "Indexing to self-hosted data layer";
      try {
        await this.indexContentWithSpinner({
          text,
          database,
          graphQLSchema,
          tinaSchema,
          configManager,
          partialReindex: this.partialReindex
        });
      } catch (e) {
        logger.error(`

${dangerText(e.message)}
`);
        if (this.verbose) {
          console.error(e);
        }
        process.exit(1);
      }
    }
    if (this.localOption) {
      server = await createDevServer(
        configManager,
        database,
        null,
        apiURL,
        true
      );
      await server.listen(Number(this.port));
      console.log("server listening on port", this.port);
    }
    const skipCloudChecks = this.skipCloudChecks || configManager.hasSelfHostedConfig();
    if (!skipCloudChecks) {
      await this.checkClientInfo(configManager, codegen2.productionUrl);
      await waitForDB(configManager.config, codegen2.productionUrl, false);
      await this.checkGraphqlSchema(
        configManager,
        database,
        codegen2.productionUrl
      );
    }
    await buildProductionSpa(configManager, database, codegen2.productionUrl);
    await import_fs_extra7.default.outputFile(
      configManager.outputGitignorePath,
      "index.html\nassets/"
    );
    if (configManager.config.search && !this.skipSearchIndex && !this.localOption) {
      let client;
      const hasTinaSearch = Boolean((_b = (_a = configManager.config) == null ? void 0 : _a.search) == null ? void 0 : _b.tina);
      if (hasTinaSearch) {
        if (!((_c = configManager.config) == null ? void 0 : _c.branch)) {
          logger.error(
            `${dangerText(
              `ERROR: Branch not configured in tina search configuration.`
            )}`
          );
          throw new Error("Branch not configured in tina search configuration.");
        }
        if (!((_d = configManager.config) == null ? void 0 : _d.clientId)) {
          logger.error(`${dangerText(`ERROR: clientId not configured.`)}`);
          throw new Error("clientId not configured.");
        }
        if (!((_g = (_f = (_e = configManager.config) == null ? void 0 : _e.search) == null ? void 0 : _f.tina) == null ? void 0 : _g.indexerToken)) {
          logger.error(
            `${dangerText(
              `ERROR: indexerToken not configured in tina search configuration.`
            )}`
          );
          throw new Error(
            "indexerToken not configured in tina search configuration."
          );
        }
        client = new import_search2.TinaCMSSearchIndexClient({
          apiUrl: `${((_h = configManager.config.tinaioConfig) == null ? void 0 : _h.contentApiUrlOverride) || "https://content.tinajs.io"}/searchIndex/${(_i = configManager.config) == null ? void 0 : _i.clientId}`,
          branch: (_j = configManager.config) == null ? void 0 : _j.branch,
          indexerToken: (_m = (_l = (_k = configManager.config) == null ? void 0 : _k.search) == null ? void 0 : _l.tina) == null ? void 0 : _m.indexerToken,
          stopwordLanguages: (_p = (_o = (_n = configManager.config) == null ? void 0 : _n.search) == null ? void 0 : _o.tina) == null ? void 0 : _p.stopwordLanguages
        });
      } else {
        client = (_r = (_q = configManager.config) == null ? void 0 : _q.search) == null ? void 0 : _r.searchClient;
      }
      const searchIndexer = new import_search2.SearchIndexer({
        batchSize: ((_s = configManager.config.search) == null ? void 0 : _s.indexBatchSize) || 100,
        bridge: new import_graphql10.FilesystemBridge(
          configManager.rootPath,
          configManager.contentRootPath
        ),
        schema: tinaSchema,
        client
      });
      let err;
      await spin({
        waitFor: async () => {
          try {
            await searchIndexer.indexAllContent();
          } catch (e) {
            err = e;
          }
        },
        text: "Building search index"
      });
      if (err) {
        logger.error(`${dangerText(`ERROR: ${err.message}`)}`);
        process.exit(1);
      }
    }
    const summaryItems = [];
    if (!configManager.shouldSkipSDK()) {
      summaryItems.push({
        emoji: "\u{1F916}",
        heading: "Auto-generated files",
        subItems: [
          {
            key: "GraphQL Client",
            value: configManager.printGeneratedClientFilePath()
          },
          {
            key: "Typescript Types",
            value: configManager.printGeneratedTypesFilePath()
          }
        ]
      });
    }
    summary({
      heading: "Tina build complete",
      items: [
        {
          emoji: "\u{1F999}",
          heading: "Tina Config",
          subItems: [
            {
              key: "API url",
              value: apiURL
            }
          ]
        },
        ...summaryItems
      ]
    });
    if (this.subCommand) {
      await this.startSubCommand();
    } else {
      process.exit();
    }
  }
  async checkClientInfo(configManager, apiURL) {
    const { config: config3 } = configManager;
    const token = config3.token;
    const { clientId, branch, host } = (0, import_schema_tools2.parseURL)(apiURL);
    const url = `https://${host}/db/${clientId}/status/${branch}`;
    const bar2 = new import_progress2.default("Checking clientId and token. :prog", 1);
    let branchKnown = false;
    try {
      const res = await request({
        token,
        url
      });
      bar2.tick({
        prog: "\u2705"
      });
      if (!(res.status === "unknown")) {
        branchKnown = true;
      }
    } catch (e) {
      summary({
        heading: "Error when checking client information",
        items: [
          {
            emoji: "\u274C",
            heading: "You provided",
            subItems: [
              {
                key: "clientId",
                value: config3.clientId
              },
              {
                key: "token",
                value: config3.token
              }
            ]
          }
        ]
      });
      throw e;
    }
    const branchBar = new import_progress2.default("Checking branch is on Tina Cloud. :prog", 1);
    if (branchKnown) {
      branchBar.tick({
        prog: "\u2705"
      });
      return;
    }
    for (let i = 0; i <= 5; i++) {
      await sleepAndCallFunc({
        fn: async () => {
          const res = await request({
            token,
            url
          });
          if (this.verbose) {
            logger.info(
              `Branch status: ${res.status}. Attempt: ${i + 1}. Trying again in 5 seconds.`
            );
          }
          if (!(res.status === "unknown")) {
            branchBar.tick({
              prog: "\u2705"
            });
            return;
          }
        },
        ms: 5e3
      });
    }
    branchBar.tick({
      prog: "\u274C"
    });
    logger.error(
      `${dangerText(
        `ERROR: Branch '${branch}' is not on Tina Cloud.`
      )} Please make sure that branch '${branch}' exists in your repository and that you have pushed your all changes to the remote. View all all branches and there current status here: ${linkText(
        `https://app.tina.io/projects/${clientId}/configuration`
      )}`
    );
    throw new Error("Branch is not on Tina Cloud");
  }
  async checkGraphqlSchema(configManager, database, apiURL) {
    const bar2 = new import_progress2.default(
      "Checking local GraphQL Schema matches server. :prog",
      1
    );
    const { config: config3 } = configManager;
    const token = config3.token;
    const remoteSchema = await fetchRemoteGraphqlSchema({
      url: apiURL,
      token
    });
    if (!remoteSchema) {
      bar2.tick({
        prog: "\u274C"
      });
      let errorMessage = `The remote GraphQL schema does not exist. Check indexing for this branch.`;
      if (config3 == null ? void 0 : config3.branch) {
        errorMessage += `

Additional info: Branch: ${config3.branch}, Client ID: ${config3.clientId} `;
      }
      throw new Error(errorMessage);
    }
    const remoteGqlSchema = (0, import_graphql11.buildClientSchema)(remoteSchema);
    const localSchemaDocument = await database.getGraphQLSchemaFromBridge();
    const localGraphqlSchema = (0, import_graphql11.buildASTSchema)(localSchemaDocument);
    try {
      const diffResult = await (0, import_core2.diff)(localGraphqlSchema, remoteGqlSchema);
      if (diffResult.length === 0) {
        bar2.tick({
          prog: "\u2705"
        });
      } else {
        bar2.tick({
          prog: "\u274C"
        });
        let errorMessage = `The local GraphQL schema doesn't match the remote GraphQL schema. Please push up your changes to Github to update your remote GraphQL schema.`;
        if (config3 == null ? void 0 : config3.branch) {
          errorMessage += `

Additional info: Branch: ${config3.branch}, Client ID: ${config3.clientId} `;
        }
        throw new Error(errorMessage);
      }
    } catch (e) {
      if (e.message.startsWith("Cannot use")) {
        logger.warn(
          `${warnText(
            "Skipping schema check due to conflicting GraphQL versions"
          )}`
        );
      } else {
        throw e;
      }
    }
  }
};
BuildCommand.paths = [["build"]];
BuildCommand.usage = import_clipanion3.Command.Usage({
  category: `Commands`,
  description: `Build the CMS and autogenerated modules for usage with Tina Cloud`
});
async function request(args) {
  const headers = new import_node_fetch2.Headers();
  if (args.token) {
    headers.append("X-API-KEY", args.token);
  }
  headers.append("Content-Type", "application/json");
  const url = args == null ? void 0 : args.url;
  const res = await (0, import_node_fetch2.default)(url, {
    method: "GET",
    headers,
    redirect: "follow"
  });
  const json = await res.json();
  if (!res.ok) {
    let additionalInfo = "";
    if (res.status === 401 || res.status === 403) {
      additionalInfo = "Please check that your client ID, URL and read only token are configured properly.";
    }
    if (json) {
      additionalInfo += `

Message from server: ${json.message}`;
    }
    throw new Error(
      `Server responded with status code ${res.status}, ${res.statusText}. ${additionalInfo ? additionalInfo : ""} Please see our FAQ for more information: https://tina.io/docs/errors/faq/`
    );
  }
  if (json.errors) {
    throw new Error(
      `Unable to fetch, please see our FAQ for more information: https://tina.io/docs/errors/faq/

      Errors: 
	${json.errors.map((error) => error.message).join("\n")}`
    );
  }
  return {
    status: json == null ? void 0 : json.status,
    timestamp: json == null ? void 0 : json.timestamp
  };
}
var fetchRemoteGraphqlSchema = async ({
  url,
  token
}) => {
  const headers = new import_node_fetch2.Headers();
  if (token) {
    headers.append("X-API-KEY", token);
  }
  const body = JSON.stringify({ query: (0, import_graphql11.getIntrospectionQuery)(), variables: {} });
  headers.append("Content-Type", "application/json");
  const res = await (0, import_node_fetch2.default)(url, {
    method: "POST",
    headers,
    body
  });
  const data = await res.json();
  return data == null ? void 0 : data.data;
};

// src/next/commands/audit-command/index.ts
var import_clipanion4 = require("clipanion");
var import_graphql13 = require("@tinacms/graphql");

// src/next/commands/audit-command/audit.ts
var import_prompts = __toESM(require("prompts"));
var import_metrics = require("@tinacms/metrics");
var import_graphql12 = require("@tinacms/graphql");
var import_chalk5 = __toESM(require("chalk"));
var audit = async ({
  database,
  clean,
  useDefaultValues,
  noTelemetry,
  verbose
}) => {
  const telemetry = new import_metrics.Telemetry({ disabled: noTelemetry });
  await telemetry.submitRecord({
    event: {
      name: "tinacms:cli:audit:invoke",
      clean: Boolean(clean),
      useDefaults: Boolean(useDefaultValues)
    }
  });
  if (clean) {
    logger.info(
      `You are using the \`--clean\` option. This will modify your content as if a user is submitting a form. Before running this you should have a ${import_chalk5.default.bold(
        "clean git tree"
      )} so unwanted changes can be undone.

`
    );
    const res = await (0, import_prompts.default)({
      name: "useClean",
      type: "confirm",
      message: `Do you want to continue?`
    });
    if (!res.useClean) {
      logger.warn(import_chalk5.default.yellowBright("\u26A0\uFE0F Audit not complete"));
      process.exit(0);
    }
  }
  if (useDefaultValues && !clean) {
    logger.warn(
      import_chalk5.default.yellowBright(
        "WARNING: using the `--useDefaultValues` without the `--clean` flag has no effect. Please re-run audit and add the `--clean` flag"
      )
    );
  }
  const schema = await database.getSchema();
  const collections = schema.getCollections();
  let error = false;
  for (let i = 0; i < collections.length; i++) {
    const collection = collections[i];
    const docs = await database.query(
      { collection: collection.name, first: -1, filterChain: [] },
      (item) => ({ path: item })
    );
    logger.info(
      `Checking ${neutralText(collection.name)} collection. ${docs.edges.length} Documents`
    );
    const returnError = await auditDocuments({
      collection,
      database,
      useDefaultValues,
      documents: docs.edges,
      verbose
    });
    error = error || returnError;
  }
  if (error) {
    logger.error(
      import_chalk5.default.redBright(`\u203C\uFE0F Audit ${import_chalk5.default.bold("failed")} with errors`)
    );
  } else {
    logger.info(import_chalk5.default.greenBright("\u2705 Audit passed"));
  }
};
var auditDocuments = async (args) => {
  const { collection, database, useDefaultValues, documents } = args;
  let error = false;
  for (let i = 0; i < documents.length; i++) {
    const node = documents[i].node;
    const relativePath = node.path.replace(`${collection.path}/`, "");
    const documentQuery = `query {
        document(collection: "${collection.name}", relativePath: "${relativePath}") {
          __typename
          ...on Document {
            _values
          }
        }
      }`;
    const docResult = await (0, import_graphql12.resolve)({
      database,
      query: documentQuery,
      variables: {},
      silenceErrors: true,
      verbose: args.verbose || false,
      isAudit: true
    });
    if (docResult.errors) {
      error = true;
      docResult.errors.forEach((err) => {
        logger.error(import_chalk5.default.red(err.message));
        if (err.originalError.originalError) {
          logger.error(
            import_chalk5.default.red(`    ${err.originalError.originalError.message}`)
          );
        }
      });
    } else {
      const topLevelDefaults = {};
      if (useDefaultValues && typeof collection.fields !== "string") {
        collection.fields.filter((x) => !x.list).forEach((x) => {
          const value = x.ui;
          if (typeof value !== "undefined") {
            topLevelDefaults[x.name] = value.defaultValue;
          }
        });
      }
      const tinaSchema = await database.getSchema();
      const values = mergeValuesWithDefaults(
        docResult.data.document._values,
        topLevelDefaults
      );
      const params = tinaSchema.transformPayload(collection.name, values);
      const mutation = `mutation($collection: String!, $relativePath: String!, $params: DocumentUpdateMutation!) {
        updateDocument(
          collection: $collection,
          relativePath: $relativePath,
          params: $params
        ){__typename}
      }`;
      const mutationRes = await (0, import_graphql12.resolve)({
        database,
        query: mutation,
        variables: {
          params,
          collection: collection.name,
          relativePath
        },
        isAudit: true,
        silenceErrors: true,
        verbose: args.verbose || false
      });
      if (mutationRes.errors) {
        mutationRes.errors.forEach((err) => {
          error = true;
          logger.error(import_chalk5.default.red(err.message));
        });
      }
    }
  }
  return error;
};
var mergeValuesWithDefaults = (document, defaults) => {
  return { ...defaults, ...filterObject(document) };
};
function filterObject(obj) {
  const ret = {};
  Object.keys(obj).filter((key) => obj[key] !== void 0).forEach((key) => ret[key] = obj[key]);
  return ret;
}

// src/next/commands/audit-command/index.ts
var import_graphql14 = require("@tinacms/graphql");
var AuditCommand = class extends import_clipanion4.Command {
  constructor() {
    super(...arguments);
    this.rootPath = import_clipanion4.Option.String("--rootPath", {
      description: "Specify the root directory to run the CLI from"
    });
    this.verbose = import_clipanion4.Option.Boolean("-v,--verbose", false, {
      description: "increase verbosity of logged output"
    });
    this.clean = import_clipanion4.Option.Boolean("--clean", false, {
      description: "Clean the output"
    });
    this.useDefaultValues = import_clipanion4.Option.Boolean("--useDefaultValues", false, {
      description: "When cleaning the output, use defaults on the config"
    });
    this.noTelemetry = import_clipanion4.Option.Boolean("--noTelemetry", false, {
      description: "Disable anonymous telemetry that is collected"
    });
    this.datalayerPort = import_clipanion4.Option.String("--datalayer-port", "9000", {
      description: "Specify a port to run the datalayer server on. (default 9000)"
    });
  }
  async catch(error) {
    logger.error("Error occured during tinacms audit");
    if (this.verbose) {
      console.error(error);
    }
    process.exit(1);
  }
  async execute() {
    const configManager = new ConfigManager({ rootPath: this.rootPath });
    logger.info("Starting Tina Audit");
    try {
      await configManager.processConfig();
    } catch (e) {
      logger.error(e.message);
      process.exit(1);
    }
    createDBServer(Number(this.datalayerPort));
    const database = await createAndInitializeDatabase(
      configManager,
      Number(this.datalayerPort),
      this.clean ? void 0 : new import_graphql14.AuditFileSystemBridge(configManager.rootPath)
    );
    const { tinaSchema, graphQLSchema, lookup } = await (0, import_graphql13.buildSchema)(
      configManager.config
    );
    const warnings = [];
    await spin({
      waitFor: async () => {
        const res = await database.indexContent({
          graphQLSchema,
          tinaSchema,
          lookup
        });
        warnings.push(...res.warnings);
      },
      text: "Indexing local files"
    });
    if (warnings.length > 0) {
      logger.warn(`Indexing completed with ${warnings.length} warning(s)`);
      warnings.forEach((warning) => {
        logger.warn(warnText(`${warning}`));
      });
    }
    await audit({
      database,
      clean: this.clean,
      noTelemetry: this.noTelemetry,
      useDefaultValues: this.useDefaultValues,
      verbose: this.verbose
    });
    process.exit();
  }
};
AuditCommand.paths = [["audit"]];
AuditCommand.usage = import_clipanion4.Command.Usage({
  category: `Commands`,
  description: `Audit config and content files`
});

// src/next/commands/init-command/index.ts
var import_clipanion6 = require("clipanion");

// src/cmds/init/index.ts
var import_path11 = __toESM(require("path"));
var import_prettier2 = require("prettier");
var import_fs_extra11 = __toESM(require("fs-extra"));
var import_prompts2 = __toESM(require("prompts"));
var import_metrics2 = require("@tinacms/metrics");

// src/cmds/init/setup-files/index.ts
var nextPostPage = ({
  usingSrc
}) => `// THIS FILE HAS BEEN GENERATED WITH THE TINA CLI.
  // This is a demo file once you have tina setup feel free to delete this file

  import Head from 'next/head'
  import { useTina } from 'tinacms/dist/react'
  import { TinaMarkdown } from 'tinacms/dist/rich-text'
  import client from '${usingSrc ? "../" : ""}../../../tina/__generated__/client'

  const BlogPage = (props) => {
    const { data } = useTina({
      query: props.query,
      variables: props.variables,
      data: props.data,
    })

    return (
      <>
        <Head>
          {/* Tailwind CDN */}
          <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.7/tailwind.min.css"
            integrity="sha512-y6ZMKFUQrn+UUEVoqYe8ApScqbjuhjqzTuwUMEGMDuhS2niI8KA3vhH2LenreqJXQS+iIXVTRL2iaNfJbDNA1Q=="
            crossOrigin="anonymous"
            referrerPolicy="no-referrer"
          />
        </Head>
        <div>
          <div
            style={{
              textAlign: 'center',
            }}
          >
            <h1 className="text-3xl m-8 text-center leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl">
              {data.post.title}
            </h1>
            <ContentSection content={data.post.body}></ContentSection>
          </div>
          <div className="bg-green-100 text-center">
            Lost and looking for a place to start?
            <a
              href="https://tina.io/guides/tina-cloud/getting-started/overview/"
              className="text-blue-500 underline"
            >
              {' '}
              Check out this guide
            </a>{' '}
            to see how add TinaCMS to an existing Next.js site.
          </div>
        </div>
      </>
    )
  }

  export const getStaticProps = async ({ params }) => {
    let data = {}
    let query = {}
    let variables = { relativePath: \`\${params.filename}.md\` }
    try {
      const res = await client.queries.post(variables)
      query = res.query
      data = res.data
      variables = res.variables
    } catch {
      // swallow errors related to document creation
    }

    return {
      props: {
        variables: variables,
        data: data,
        query: query,
        //myOtherProp: 'some-other-data',
      },
    }
  }

  export const getStaticPaths = async () => {
    const postsListData = await client.queries.postConnection()

    return {
      paths: postsListData.data.postConnection.edges.map((post) => ({
        params: { filename: post.node._sys.filename },
      })),
      fallback: false,
    }
  }

  export default BlogPage

  const PageSection = (props) => {
    return (
      <>
        <h2>{props.heading}</h2>
        <p>{props.content}</p>
      </>
    )
  }

  const components = {
    PageSection: PageSection,
  }

  const ContentSection = ({ content }) => {
    return (
      <div className="relative py-16 bg-white overflow-hidden">
        <div className="hidden lg:block lg:absolute lg:inset-y-0 lg:h-full lg:w-full">
          <div
            className="relative h-full text-lg max-w-prose mx-auto"
            aria-hidden="true"
          >
            <svg
              className="absolute top-12 left-full transform translate-x-32"
              width={404}
              height={384}
              fill="none"
              viewBox="0 0 404 384"
            >
              <defs>
                <pattern
                  id="74b3fd99-0a6f-4271-bef2-e80eeafdf357"
                  x={0}
                  y={0}
                  width={20}
                  height={20}
                  patternUnits="userSpaceOnUse"
                >
                  <rect
                    x={0}
                    y={0}
                    width={4}
                    height={4}
                    className="text-gray-200"
                    fill="currentColor"
                  />
                </pattern>
              </defs>
              <rect
                width={404}
                height={384}
                fill="url(#74b3fd99-0a6f-4271-bef2-e80eeafdf357)"
              />
            </svg>
            <svg
              className="absolute top-1/2 right-full transform -translate-y-1/2 -translate-x-32"
              width={404}
              height={384}
              fill="none"
              viewBox="0 0 404 384"
            >
              <defs>
                <pattern
                  id="f210dbf6-a58d-4871-961e-36d5016a0f49"
                  x={0}
                  y={0}
                  width={20}
                  height={20}
                  patternUnits="userSpaceOnUse"
                >
                  <rect
                    x={0}
                    y={0}
                    width={4}
                    height={4}
                    className="text-gray-200"
                    fill="currentColor"
                  />
                </pattern>
              </defs>
              <rect
                width={404}
                height={384}
                fill="url(#f210dbf6-a58d-4871-961e-36d5016a0f49)"
              />
            </svg>
            <svg
              className="absolute bottom-12 left-full transform translate-x-32"
              width={404}
              height={384}
              fill="none"
              viewBox="0 0 404 384"
            >
              <defs>
                <pattern
                  id="d3eb07ae-5182-43e6-857d-35c643af9034"
                  x={0}
                  y={0}
                  width={20}
                  height={20}
                  patternUnits="userSpaceOnUse"
                >
                  <rect
                    x={0}
                    y={0}
                    width={4}
                    height={4}
                    className="text-gray-200"
                    fill="currentColor"
                  />
                </pattern>
              </defs>
              <rect
                width={404}
                height={384}
                fill="url(#d3eb07ae-5182-43e6-857d-35c643af9034)"
              />
            </svg>
          </div>
        </div>
        <div className="relative px-4 sm:px-6 lg:px-8">
          <div className="text-lg max-w-prose mx-auto">
            <TinaMarkdown components={components} content={content} />
          </div>
        </div>
      </div>
    )
  }`;

// src/utils/script-helpers.ts
function generateGqlScript(scriptValue) {
  return `tinacms dev -c "${scriptValue}"`;
}
function extendNextScripts(scripts) {
  return {
    ...scripts,
    dev: generateGqlScript((scripts == null ? void 0 : scripts.dev) || "next dev"),
    build: `tinacms build && ${(scripts == null ? void 0 : scripts.build) || "next build"}`,
    start: `tinacms build && ${(scripts == null ? void 0 : scripts.start) || "next start"}`
  };
}

// src/cmds/init/setup-files/config.ts
var clientConfig = (isForestryMigration) => {
  if (isForestryMigration) {
    return "client: {skip: true},";
  }
  return "";
};
var other = (args) => {
  return `
import { defineConfig } from "tinacms";
${args.extraText || ""}

// Your hosting provider likely exposes this as an environment variable
const branch = process.env.HEAD || process.env.VERCEL_GIT_COMMIT_REF || "main";

export default defineConfig({
  branch,
  clientId: ${args.clientId ? `'${args.clientId}'` : "null"}, // Get this from tina.io
  token:  ${args.token ? `'${args.token}'` : "null"}, // Get this from tina.io
  ${clientConfig(args.isForestryMigration)}
  build: {
    outputFolder: "admin",
    publicFolder: "${args.publicFolder}",
  },
  media: {
    tina: {
      mediaRoot: "",
      publicFolder: "${args.publicFolder}",
    },
  },
  schema: {
    collections: ${args.collections || `[
      {
        name: "post",
        label: "Posts",
        path: "content/posts",
        fields: [
          {
            type: "string",
            name: "title",
            label: "Title",
            isTitle: true,
            required: true,
          },
          {
            type: "rich-text",
            name: "body",
            label: "Body",
            isBody: true,
          },
        ],
      },
    ]`},
  },
});
`;
};
var configExamples = {
  next: (args) => `import { defineConfig } from 'tinacms'

  // Your hosting provider likely exposes this as an environment variable
  const branch = process.env.HEAD || process.env.VERCEL_GIT_COMMIT_REF || 'main'

  export default defineConfig({
    branch,
    clientId: ${args.clientId ? `'${args.clientId}'` : "null"}, // Get this from tina.io
    token:  ${args.token ? `'${args.token}'` : "null"}, // Get this from tina.io
    ${clientConfig(args.isForestryMigration)}
    build: {
      outputFolder: "admin",
      publicFolder: "${args.publicFolder}",
    },
    media: {
      tina: {
        mediaRoot: "",
        publicFolder: "${args.publicFolder}",
      },
    },
    schema: {
      collections:${args.collections || `[
        {
          name: 'post',
          label: 'Posts',
          path: 'content/posts',
          fields: [
            {
              type: 'string',
              name: 'title',
              label: 'Title',
              isTitle: true,
              required: true,
            },
            {
              type: 'rich-text',
              name: 'body',
              label: 'Body',
              isBody: true,
            },
          ],
          ui: {
            // This is an DEMO router. You can remove this to fit your site
            router: ({ document }) => \`/demo/blog/\${document._sys.filename}\`,
          },
        },
      ]`},
    },
  })
  `,
  other,
  hugo: other,
  jekyll: other
};

// src/cmds/forestry-migrate/index.ts
var import_fs_extra9 = __toESM(require("fs-extra"));
var import_path9 = __toESM(require("path"));
var import_js_yaml2 = __toESM(require("js-yaml"));
var import_minimatch = __toESM(require("minimatch"));
var import_graphql15 = require("@tinacms/graphql");

// src/cmds/forestry-migrate/util/index.ts
var import_fs_extra8 = __toESM(require("fs-extra"));
var import_path8 = __toESM(require("path"));
var import_js_yaml = __toESM(require("js-yaml"));
var import_zod = __toESM(require("zod"));

// src/cmds/forestry-migrate/util/errorSingleton.ts
var ErrorSingleton = class {
  constructor() {
  }
  static getInstance() {
    if (!ErrorSingleton.instance) {
      ErrorSingleton.instance = new ErrorSingleton();
      ErrorSingleton.instance.collectionNameErrors = [];
    }
    return ErrorSingleton.instance;
  }
  addErrorName(error) {
    this.collectionNameErrors.push(error);
  }
  printCollectionNameErrors() {
    var _a;
    if ((_a = this.collectionNameErrors) == null ? void 0 : _a.length) {
      logger.error(
        dangerText("ERROR: TinaCMS only supports alphanumeric template names")
      );
      logger.error("The following templates have been renamed:");
      this.collectionNameErrors.forEach((error) => {
        logger.error(`- ${error.template}.yaml -> ${error.newName}`);
      });
      logger.error(
        `If you wish to edit any of the following templates, you will have to update your content and code to use the new name. See ${linkText(
          "https://tina.io/docs/forestry/common-errors/#migrating-fields-with-non-alphanumeric-characters"
        )} for more information.`
      );
    }
  }
};

// src/cmds/forestry-migrate/util/codeTransformer.ts
var import_prettier = require("prettier");
var import_parser_typescript = __toESM(require("prettier/parser-typescript"));
var addVariablesToCode = (codeWithTinaPrefix) => {
  const code = codeWithTinaPrefix.replace(
    /"__TINA_INTERNAL__:::(.*?):::"/g,
    "$1"
  );
  return { code };
};
var makeFieldsWithInternalCode = ({
  hasBody,
  field,
  bodyField,
  spread
}) => {
  if (hasBody) {
    return [bodyField, `__TINA_INTERNAL__:::...${field}():::`];
  } else {
    if (spread)
      return `__TINA_INTERNAL__:::...${field}():::`;
    return `__TINA_INTERNAL__:::${field}():::`;
  }
};
var makeTemplateFile = async ({
  templateMap,
  usingTypescript
}) => {
  const importStatements = [];
  const templateCodeText = [];
  for (const template of templateMap.values()) {
    importStatements.push(
      `import { ${stringifyLabelWithField(
        template.templateObj.label
      )} } from './templates'`
    );
    templateCodeText.push(
      `export function ${stringifyLabelWithField(
        template.templateObj.label
      )} (){
        return ${addVariablesToCode(JSON.stringify(template.fields, null, 2)).code} ${usingTypescript ? "as TinaField[]" : ""} 
      } `
    );
  }
  const templateCode = `
${usingTypescript ? "import type { TinaField } from 'tinacms'" : ""}
${templateCodeText.join("\n")}
  `;
  const formattedCode = (0, import_prettier.format)(templateCode, {
    parser: "typescript",
    plugins: [import_parser_typescript.default]
  });
  return { importStatements, templateCodeText: formattedCode };
};

// src/cmds/forestry-migrate/util/index.ts
var errorSingletonInstance = ErrorSingleton.getInstance();
var NAME_TEST_REGEX = /^[a-zA-Z0-9_]*$/;
var NAME_UPDATE_REGEX = /[^a-zA-Z0-9]/g;
var getTinaFieldsFromName = (name2) => {
  if (name2 == "id") {
    return { name: "custom_id", nameOverride: "id" };
  } else {
    if (NAME_TEST_REGEX.test(name2)) {
      return { name: name2 };
    } else {
      return {
        name: name2.replace(NAME_UPDATE_REGEX, "_"),
        nameOverride: name2
      };
    }
  }
};
var stringifyTemplateName = (name2, template) => {
  if (NAME_TEST_REGEX.test(name2)) {
    return name2;
  } else {
    const newName = name2.replace(NAME_UPDATE_REGEX, "_");
    errorSingletonInstance.addErrorName({ name: name2, newName, template });
    return newName;
  }
};
var forestryConfigSchema = import_zod.default.object({
  sections: import_zod.default.array(
    import_zod.default.object({
      type: import_zod.default.union([
        import_zod.default.literal("directory"),
        import_zod.default.literal("document"),
        import_zod.default.literal("heading"),
        import_zod.default.literal("jekyll-pages"),
        import_zod.default.literal("jekyll-posts")
      ]),
      label: import_zod.default.string(),
      path: import_zod.default.string().optional().nullable(),
      match: import_zod.default.string().optional().nullable(),
      exclude: import_zod.default.string().optional().nullable(),
      create: import_zod.default.union([import_zod.default.literal("all"), import_zod.default.literal("documents"), import_zod.default.literal("none")]).optional(),
      templates: import_zod.default.array(import_zod.default.string()).optional().nullable(),
      new_doc_ext: import_zod.default.string().optional().nullable(),
      read_only: import_zod.default.boolean().optional().nullable()
    })
  )
});
var forestryFieldWithoutField = import_zod.default.object({
  type: import_zod.default.union([
    import_zod.default.literal("text"),
    import_zod.default.literal("datetime"),
    import_zod.default.literal("list"),
    import_zod.default.literal("file"),
    import_zod.default.literal("image_gallery"),
    import_zod.default.literal("textarea"),
    import_zod.default.literal("tag_list"),
    import_zod.default.literal("number"),
    import_zod.default.literal("boolean"),
    import_zod.default.literal("field_group"),
    import_zod.default.literal("field_group_list"),
    import_zod.default.literal("select"),
    import_zod.default.literal("include"),
    import_zod.default.literal("blocks"),
    import_zod.default.literal("color")
  ]),
  template_types: import_zod.default.array(import_zod.default.string()).optional().nullable(),
  name: import_zod.default.string(),
  label: import_zod.default.string(),
  default: import_zod.default.any().optional(),
  template: import_zod.default.string().optional(),
  config: import_zod.default.object({
    min: import_zod.default.number().optional().nullable(),
    max: import_zod.default.number().optional().nullable(),
    required: import_zod.default.boolean().optional().nullable(),
    use_select: import_zod.default.boolean().optional().nullable(),
    date_format: import_zod.default.string().optional().nullable(),
    time_format: import_zod.default.string().optional().nullable(),
    options: import_zod.default.array(import_zod.default.string()).optional().nullable(),
    source: import_zod.default.object({
      type: import_zod.default.union([
        import_zod.default.literal("custom"),
        import_zod.default.literal("pages"),
        import_zod.default.literal("documents"),
        import_zod.default.literal("simple"),
        import_zod.default.string()
      ]).optional().nullable(),
      section: import_zod.default.string().optional().nullable()
    }).optional()
  }).optional()
});
var forestryField = import_zod.default.lazy(
  () => forestryFieldWithoutField.extend({
    fields: import_zod.default.array(forestryField).optional()
  })
);
var FrontmatterTemplateSchema = import_zod.default.object({
  label: import_zod.default.string(),
  hide_body: import_zod.default.boolean().optional(),
  fields: import_zod.default.array(forestryField).optional()
});
var transformForestryFieldsToTinaFields = ({
  fields,
  pathToForestryConfig,
  template,
  skipBlocks = false
}) => {
  const tinaFields = [];
  fields == null ? void 0 : fields.forEach((forestryField2) => {
    var _a, _b, _c, _d;
    if (forestryField2.name === "menu") {
      logger.info(
        warnText(
          `skipping menu field template ${template}.yaml since TinaCMS does not support Hugo or Jekyll menu fields`
        )
      );
      return;
    }
    let field;
    switch (forestryField2.type) {
      case "text":
        field = {
          type: "string",
          ...getTinaFieldsFromName(forestryField2.name),
          label: forestryField2.label
        };
        break;
      case "textarea":
        field = {
          type: "string",
          ...getTinaFieldsFromName(forestryField2.name),
          label: forestryField2.label,
          ui: {
            component: "textarea"
          }
        };
        break;
      case "datetime":
        field = {
          type: forestryField2.type,
          ...getTinaFieldsFromName(forestryField2.name),
          label: forestryField2.label
        };
        break;
      case "number":
        field = {
          type: "number",
          ...getTinaFieldsFromName(forestryField2.name),
          label: forestryField2.label
        };
        break;
      case "boolean":
        field = {
          type: "boolean",
          ...getTinaFieldsFromName(forestryField2.name),
          label: forestryField2.label
        };
        break;
      case "color":
        field = {
          type: "string",
          ...getTinaFieldsFromName(forestryField2.name),
          label: forestryField2.label,
          ui: {
            component: "color"
          }
        };
        break;
      case "file":
        field = {
          type: "image",
          ...getTinaFieldsFromName(forestryField2.name),
          label: forestryField2.label
        };
        break;
      case "image_gallery":
        field = {
          type: "image",
          ...getTinaFieldsFromName(forestryField2.name),
          label: forestryField2.label,
          list: true
        };
        break;
      case "select":
        if ((_a = forestryField2.config) == null ? void 0 : _a.options) {
          field = {
            type: "string",
            ...getTinaFieldsFromName(forestryField2.name),
            label: forestryField2.label,
            options: ((_b = forestryField2.config) == null ? void 0 : _b.options) || []
          };
        } else {
          logger.info(
            warnText(
              `Warning in template ${template}.yaml . "select" field migration has only been implemented for simple select. Other versions of select have not been implemented yet. To make your \`${forestryField2.name}\` field work, you will need to manually add it to your schema.`
            )
          );
        }
        break;
      case "list":
        field = {
          type: "string",
          ...getTinaFieldsFromName(forestryField2.name),
          label: forestryField2.label,
          list: true
        };
        if ((_c = forestryField2.config) == null ? void 0 : _c.options) {
          field.options = forestryField2.config.options;
        }
        break;
      case "tag_list":
        field = {
          type: "string",
          ...getTinaFieldsFromName(forestryField2.name),
          label: forestryField2.label,
          list: true,
          ui: {
            component: "tags"
          }
        };
        break;
      case "field_group":
        field = {
          type: "object",
          ...getTinaFieldsFromName(forestryField2.name),
          label: forestryField2.label,
          fields: transformForestryFieldsToTinaFields({
            fields: forestryField2.fields,
            pathToForestryConfig,
            template,
            skipBlocks
          })
        };
        break;
      case "field_group_list":
        field = {
          type: "object",
          ...getTinaFieldsFromName(forestryField2.name),
          label: forestryField2.label,
          list: true,
          fields: transformForestryFieldsToTinaFields({
            fields: forestryField2.fields,
            template,
            pathToForestryConfig,
            skipBlocks
          })
        };
        break;
      case "blocks": {
        if (skipBlocks) {
          break;
        }
        const templates = [];
        forestryField2 == null ? void 0 : forestryField2.template_types.forEach((tem) => {
          const { template: template2 } = getFieldsFromTemplates({
            tem,
            skipBlocks: true,
            pathToForestryConfig
          });
          const fieldsString = stringifyLabelWithField(template2.label);
          const t = {
            fields: makeFieldsWithInternalCode({
              hasBody: false,
              field: fieldsString
            }),
            label: template2.label,
            name: stringifyTemplateName(tem, tem)
          };
          if (t.name != tem) {
            ;
            t.nameOverride = tem;
          }
          templates.push(t);
        });
        field = {
          type: "object",
          list: true,
          templateKey: "template",
          label: forestryField2.label,
          ...getTinaFieldsFromName(forestryField2.name),
          templates
        };
        break;
      }
      case "include": {
        const tem = forestryField2.template;
        const { template: template2 } = getFieldsFromTemplates({
          tem,
          skipBlocks: true,
          pathToForestryConfig
        });
        const fieldsString = stringifyLabelWithField(template2.label);
        const field2 = makeFieldsWithInternalCode({
          field: fieldsString,
          hasBody: false,
          spread: true
        });
        tinaFields.push(
          field2
        );
        break;
      }
      default:
        logger.info(
          warnText(
            `Warning in template ${template}. "${forestryField2.type}" migration has not been implemented yet. To make your \`${forestryField2.name}\` field work, you will need to manually add it to your schema.`
          )
        );
    }
    if (field) {
      if ((_d = forestryField2.config) == null ? void 0 : _d.required) {
        field = { ...field, required: true };
      }
      tinaFields.push(field);
    }
  });
  return tinaFields;
};
var getFieldsFromTemplates = ({ tem, pathToForestryConfig, skipBlocks = false }) => {
  const templatePath = import_path8.default.join(
    pathToForestryConfig,
    ".forestry",
    "front_matter",
    "templates",
    `${tem}.yml`
  );
  let templateString = "";
  try {
    templateString = import_fs_extra8.default.readFileSync(templatePath).toString();
  } catch {
    throw new Error(
      `Could not find template ${tem} at ${templatePath}

 This will require manual migration.`
    );
  }
  const templateObj = import_js_yaml.default.load(templateString);
  const template = parseTemplates({ val: templateObj });
  const fields = transformForestryFieldsToTinaFields({
    fields: template.fields,
    pathToForestryConfig,
    template: tem,
    skipBlocks
  });
  return { fields, templateObj, template };
};
var parseTemplates = ({ val }) => {
  const template = FrontmatterTemplateSchema.parse(val);
  return template;
};
var parseSections = ({ val }) => {
  const schema = forestryConfigSchema.parse(val);
  return schema;
};

// src/cmds/forestry-migrate/index.ts
var BODY_FIELD = {
  type: "rich-text",
  name: "body",
  label: "Body of Document",
  description: "This is the markdown body",
  isBody: true
};
var stringifyLabel = (label) => {
  return label.replace(/[^a-zA-Z0-9]/g, "_").toLowerCase();
};
var stringifyLabelWithField = (label) => {
  const labelString = stringifyLabel(label);
  return `${labelString}Fields`;
};
var transformForestryMatchToTinaMatch = (match) => {
  var _a, _b;
  const newMatch = (_b = (_a = match.replace(" ", "").replace(/\.?(mdx|md|json|yaml|yml|toml)/g, "")) == null ? void 0 : _a.replace(/\..*$/g, "")) == null ? void 0 : _b.replace("{}", "");
  if (match !== newMatch) {
    logger.info(
      `Info: Match ${match} was transformed to ${newMatch}. See ${linkText(
        "https://tina.io/docs/forestry/common-errors/#info-match-match-was-transformed-to-newmatch"
      )}`
    );
  }
  return newMatch;
};
function checkExt(ext) {
  const extReal = ext.replace(".", "");
  if (["mdx", "md", "json", "yaml", "yml", "toml"].includes(extReal)) {
    return extReal;
  } else {
    return false;
  }
}
var generateAllTemplates = async ({
  pathToForestryConfig
}) => {
  const allTemplates = (await import_fs_extra9.default.readdir(
    import_path9.default.join(pathToForestryConfig, ".forestry", "front_matter", "templates")
  )).map((tem) => import_path9.default.basename(tem, ".yml"));
  const templateMap = /* @__PURE__ */ new Map();
  const proms = allTemplates.map(async (tem) => {
    try {
      const { fields, templateObj } = getFieldsFromTemplates({
        tem,
        pathToForestryConfig
      });
      templateMap.set(tem, { fields, templateObj });
    } catch (e) {
      logger.log(`Error parsing template frontmatter template', tem + '.yml'`);
      console.error(e);
      templateMap.set(tem, { fields: [], templateObj: {} });
    }
  });
  await Promise.all(proms);
  return templateMap;
};
var generateCollectionFromForestrySection = (args) => {
  const { section, templateMap } = args;
  if (section.read_only)
    return;
  let format3 = "md";
  if (section.new_doc_ext) {
    const ext = checkExt(section.new_doc_ext);
    if (ext) {
      format3 = ext;
    }
  }
  const baseCollection = {
    format: format3,
    label: section.label,
    name: stringifyLabel(section.label),
    path: section.path || "/"
  };
  if (args.frontMatterFormat) {
    baseCollection.frontmatterFormat = args.frontMatterFormat;
    if (args.frontMatterFormat === "toml") {
      baseCollection.frontmatterDelimiters = "+++";
    }
  }
  if (section.match) {
    baseCollection.match = {
      ...(baseCollection == null ? void 0 : baseCollection.match) || {},
      include: transformForestryMatchToTinaMatch(section.match)
    };
  }
  if (section.exclude) {
    baseCollection.match = {
      ...(baseCollection == null ? void 0 : baseCollection.match) || {},
      exclude: transformForestryMatchToTinaMatch(section.exclude)
    };
  }
  if (section.type === "directory") {
    if (!(section == null ? void 0 : section.path) || section.path === "/" || section.path === "./" || section.path === ".") {
      logger.log(
        warnText(
          `Warning: Section ${section.label} is using a Root Path. Currently, Tina Does not support Root paths see ${linkText(
            "https://github.com/tinacms/tinacms/issues/3768"
          )} for more updates on this issue.`
        )
      );
      return;
    }
    const forestryTemplates = (section == null ? void 0 : section.templates) || [];
    if (forestryTemplates.length === 0 && section.create === "all") {
      for (const templateKey of templateMap.keys()) {
        const { templateObj } = templateMap.get(templateKey);
        const pages = templateObj == null ? void 0 : templateObj.pages;
        if (pages) {
          let glob = section.match;
          const skipPath = section.path === "" || section.path === "/" || !section.path;
          if (!skipPath) {
            glob = section.path + "/" + section.match;
          }
          if (pages.some((page) => {
            return (0, import_minimatch.default)(page, glob);
          })) {
            forestryTemplates.push(templateKey);
          }
        }
      }
    }
    const hasBody = ["md", "mdx", "markdown"].includes(format3);
    let c;
    if (((forestryTemplates == null ? void 0 : forestryTemplates.length) || 0) > 1) {
      c = {
        ...baseCollection,
        templates: forestryTemplates.map((tem) => {
          const currentTemplate = templateMap.get(tem);
          const fieldsString = stringifyLabelWithField(
            currentTemplate.templateObj.label
          );
          return {
            fields: makeFieldsWithInternalCode({
              hasBody,
              field: fieldsString,
              bodyField: BODY_FIELD
            }),
            label: tem,
            name: stringifyLabel(tem)
          };
        })
      };
    }
    if ((forestryTemplates == null ? void 0 : forestryTemplates.length) === 1) {
      const tem = forestryTemplates[0];
      const template = templateMap.get(tem);
      const fieldsString = stringifyLabelWithField(template.templateObj.label);
      c = {
        ...baseCollection,
        fields: makeFieldsWithInternalCode({
          field: fieldsString,
          hasBody,
          bodyField: BODY_FIELD
        })
      };
    }
    if ((forestryTemplates == null ? void 0 : forestryTemplates.length) === 0) {
      logger.warn(
        warnText(
          `No templates found for section ${section.label}. Please see ${linkText(
            "https://tina.io/docs/forestry/content-modelling/"
          )} for more information`
        )
      );
      c = {
        ...baseCollection,
        fields: [BODY_FIELD]
      };
    }
    if ((section == null ? void 0 : section.create) === "none") {
      c.ui = {
        ...c.ui,
        allowedActions: {
          create: false
        }
      };
    }
    return c;
  } else if (section.type === "document") {
    const filePath = section.path;
    const extname = import_path9.default.extname(filePath);
    const fileName = import_path9.default.basename(filePath, extname);
    const dir = import_path9.default.dirname(filePath);
    const ext = checkExt(extname);
    if (ext) {
      const fields = [];
      if (ext === "md" || ext === "mdx") {
        fields.push(BODY_FIELD);
      }
      for (const currentTemplateName of templateMap.keys()) {
        const { templateObj, fields: additionalFields } = templateMap.get(currentTemplateName);
        const pages = (templateObj == null ? void 0 : templateObj.pages) || [];
        if (pages.includes(section.path)) {
          fields.push(...additionalFields);
          break;
        }
      }
      if (fields.length === 0) {
        fields.push({
          name: "dummy",
          label: "Dummy field",
          type: "string",
          description: "This is a dummy field, please replace it with the fields you want to edit. See https://tina.io/docs/schema/ for more info"
        });
        logger.warn(
          warnText(
            `No fields found for ${section.path}. Please add the fields you want to edit to the ${section.label} collection in the config file.`
          )
        );
      }
      return {
        ...baseCollection,
        path: dir,
        format: ext,
        ui: {
          allowedActions: {
            create: false,
            delete: false
          }
        },
        match: {
          include: fileName
        },
        fields
      };
    } else {
      logger.log(
        warnText(
          `Error: document section has an unsupported file extension: ${extname} in ${section.path}`
        )
      );
    }
  }
};
var generateCollections = async ({
  pathToForestryConfig,
  usingTypescript,
  frontMatterFormat
}) => {
  const templateMap = await generateAllTemplates({ pathToForestryConfig });
  const { importStatements, templateCodeText } = await makeTemplateFile({
    templateMap,
    usingTypescript
  });
  const forestryConfig = await import_fs_extra9.default.readFile(
    import_path9.default.join(pathToForestryConfig, ".forestry", "settings.yml")
  );
  rewriteTemplateKeysInDocs({
    templateMap,
    markdownParseConfig: {
      frontmatterFormat: frontMatterFormat,
      frontmatterDelimiters: frontMatterFormat === "toml" ? "+++" : void 0
    }
  });
  const collections = parseSections({
    val: import_js_yaml2.default.load(forestryConfig.toString())
  }).sections.map(
    (section) => generateCollectionFromForestrySection({
      section,
      templateMap,
      frontMatterFormat
    })
  ).filter((c) => c !== void 0);
  return {
    collections,
    importStatements: importStatements.join("\n"),
    templateCode: templateCodeText
  };
};
var rewriteTemplateKeysInDocs = (args) => {
  var _a;
  const { templateMap, markdownParseConfig } = args;
  for (const templateKey of templateMap.keys()) {
    const { templateObj } = templateMap.get(templateKey);
    (_a = templateObj == null ? void 0 : templateObj.pages) == null ? void 0 : _a.forEach((page) => {
      try {
        const filePath = import_path9.default.join(page);
        if (import_fs_extra9.default.lstatSync(filePath).isDirectory()) {
          return;
        }
        const extname = import_path9.default.extname(filePath);
        const fileContent = import_fs_extra9.default.readFileSync(filePath).toString();
        const content2 = (0, import_graphql15.parseFile)(
          fileContent,
          extname,
          (yup) => yup.object({}),
          markdownParseConfig
        );
        const newContent = {
          _template: stringifyLabel(templateKey),
          ...content2
        };
        import_fs_extra9.default.writeFileSync(
          filePath,
          (0, import_graphql15.stringifyFile)(newContent, extname, true, markdownParseConfig)
        );
      } catch (error) {
        console.log(
          dangerText("Error updating template -> _template in ", page)
        );
      }
    });
  }
};

// src/next/commands/codemod-command/index.ts
var import_clipanion5 = require("clipanion");
var import_fs_extra10 = __toESM(require("fs-extra"));
var import_path10 = __toESM(require("path"));
var CodemodCommand = class extends import_clipanion5.Command {
  constructor() {
    super(...arguments);
    this.rootPath = import_clipanion5.Option.String("--rootPath", {
      description: "Specify the root directory to run the CLI from"
    });
    this.verbose = import_clipanion5.Option.Boolean("-v,--verbose", false, {
      description: "increase verbosity of logged output"
    });
  }
  async catch(error) {
    console.log(error);
  }
  async execute() {
    const mod = this.path[1];
    if (!mod) {
      logger.error(
        "Must specify an additional argument (eg. 'move-tina-folder')"
      );
      process.exit(1);
    }
    const mods = { "move-tina-folder": () => moveTinaFolder(this.rootPath) };
    const command = mods[mod];
    if (!command) {
      logger.error(`Mod not found for ${mod}`);
      process.exit(1);
    }
    await command();
  }
};
CodemodCommand.paths = [["codemod"], ["codemod", "move-tina-folder"]];
CodemodCommand.usage = import_clipanion5.Command.Usage({
  category: `Commands`,
  description: `Use codemods for various Tina tasks`
});
var moveTinaFolder = async (rootPath = process.cwd()) => {
  const configManager = new ConfigManager({ rootPath });
  try {
    await configManager.processConfig();
  } catch (e) {
    logger.error(e.message);
    process.exit(1);
  }
  const tinaDestination = import_path10.default.join(configManager.rootPath, "tina");
  if (await import_fs_extra10.default.existsSync(tinaDestination)) {
    logger.info(
      `Folder already exists at ${tinaDestination}. Either delete this folder to complete the codemod, or ensure you have properly copied your config from the ".tina" folder.`
    );
  } else {
    await import_fs_extra10.default.moveSync(configManager.tinaFolderPath, tinaDestination);
    await writeGitignore(configManager.rootPath);
    logger.info(
      "Move to 'tina' folder complete. Be sure to update any imports of the autogenerated client!"
    );
  }
};
var writeGitignore = async (rootPath) => {
  await import_fs_extra10.default.outputFileSync(
    import_path10.default.join(rootPath, "tina", ".gitignore"),
    "__generated__"
  );
};

// src/cmds/init/index.ts
async function initStaticTina({
  rootPath,
  pathToForestryConfig,
  noTelemetry
}) {
  logger.level = "info";
  process.chdir(rootPath);
  const clientId = await chooseClientId();
  let token = null;
  if (clientId) {
    token = await chooseToken({ clientId });
  }
  const packageManager = await choosePackageManager();
  const framework = await chooseFramework();
  const usingTypescript = await chooseTypescript();
  const publicFolder = await choosePublicFolder({ framework });
  let collections;
  let templateCode;
  let extraText;
  const hasForestryConfig = await import_fs_extra11.default.pathExists(
    import_path11.default.join(pathToForestryConfig, ".forestry", "settings.yml")
  );
  let isForestryMigration = false;
  if (hasForestryConfig) {
    const res = await forestryMigrate({
      usingTypescript,
      pathToForestryConfig,
      rootPath,
      framework
    });
    if (res) {
      templateCode = res.templateCodeString;
      collections = res.collectionString;
      extraText = res.importStatements;
      isForestryMigration = true;
    }
  }
  await reportTelemetry({
    usingTypescript,
    hasForestryConfig,
    noTelemetry
  });
  const hasPackageJSON = await import_fs_extra11.default.pathExistsSync("package.json");
  if (!hasPackageJSON) {
    await createPackageJSON();
  }
  const hasGitignore = await import_fs_extra11.default.pathExistsSync(".gitignore");
  if (!hasGitignore) {
    await createGitignore({ baseDir: "" });
  } else {
    const hasNodeModulesIgnored = await checkGitignoreForNodeModules({
      baseDir: ""
    });
    if (!hasNodeModulesIgnored) {
      await addNodeModulesToGitignore({ baseDir: "" });
    }
  }
  await addDependencies(packageManager);
  if (isForestryMigration) {
    await addTemplateFile({ baseDir: "", usingTypescript, templateCode });
  }
  await addConfigFile({
    publicFolder: import_path11.default.join(
      import_path11.default.relative(process.cwd(), pathToForestryConfig),
      publicFolder
    ),
    baseDir: "",
    usingTypescript,
    framework,
    collections,
    token,
    clientId,
    isForestryMigration,
    extraText
  });
  if (!hasForestryConfig) {
    await addContentFile({ baseDir: "" });
  }
  if (framework.reactive) {
    await addReactiveFile[framework.name]({
      baseDir: "",
      framework,
      usingTypescript
    });
  }
  logNextSteps({ packageManager, framework });
}
var chooseClientId = async () => {
  const option = await (0, import_prompts2.default)({
    name: "clientId",
    type: "text",
    message: `What is your Tina Cloud Client ID? (Hit enter to skip and set up yourself later)
${logText(
      "Don't have a Client ID? Create one here: "
    )}${linkText("https://app.tina.io/projects/new")}`
  });
  return option["clientId"];
};
var chooseToken = async ({ clientId }) => {
  const option = await (0, import_prompts2.default)({
    name: "token",
    type: "text",
    message: `What is your Tina Cloud Read Only Token?
${logText(
      "Don't have a Read Only Token? Create one here: "
    )}${linkText(`https://app.tina.io/projects/${clientId}/tokens`)}`
  });
  return option["token"];
};
var choosePackageManager = async () => {
  const option = await (0, import_prompts2.default)({
    name: "selection",
    type: "select",
    message: "Choose your package manager",
    choices: [
      { title: "PNPM", value: "pnpm" },
      { title: "Yarn", value: "yarn" },
      { title: "NPM", value: "npm" }
    ]
  });
  return option["selection"];
};
var chooseTypescript = async () => {
  const option = await (0, import_prompts2.default)({
    name: "selection",
    type: "confirm",
    initial: true,
    message: "Would you like to use Typescript for your Tina Configuration (Recommended)?"
  });
  return option["selection"];
};
var choosePublicFolder = async ({ framework }) => {
  let suggestion = "public";
  switch (framework.name) {
    case "next":
      return "public";
    case "hugo":
      return "static";
    case "jekyll":
      suggestion = "public";
      break;
  }
  const option = await (0, import_prompts2.default)({
    name: "selection",
    type: "text",
    message: `Where are public assets stored? (default: "${suggestion}")
` + logText(
      `Not sure what value to use? Refer to our "Frameworks" doc: ${linkText(
        "https://tina.io/docs/integration/frameworks/#configuring-tina-with-each-framework"
      )}`
    )
  });
  return option["selection"] || suggestion;
};
var chooseFramework = async () => {
  const option = await (0, import_prompts2.default)({
    name: "selection",
    type: "select",
    message: "What framework are you using?",
    choices: [
      { title: "Next.js", value: { name: "next", reactive: true } },
      { title: "Hugo", value: { name: "hugo", reactive: false } },
      { title: "Jekyll", value: { name: "jekyll", reactive: false } },
      {
        title: "Other (SSG frameworks like gatsby, etc.)",
        value: { name: "other", reactive: false }
      }
    ]
  });
  return option["selection"];
};
var forestryMigrate = async ({
  pathToForestryConfig,
  usingTypescript,
  rootPath,
  framework
}) => {
  logger.info(`Forestry.io configuration found.`);
  const disclaimer = logText(
    `Note: This migration will update some of your content to match tina.  Please save a backup of your content before doing this migration. (This can be done with git)`
  );
  const option = await (0, import_prompts2.default)({
    name: "selection",
    type: "confirm",
    initial: true,
    message: `Would you like to migrate your Forestry templates?
${disclaimer}`
  });
  if (!option["selection"]) {
    return null;
  }
  let frontMatterFormat = null;
  if (framework.name === "hugo") {
    frontMatterFormat = await getFrontmatterFormat(rootPath);
  }
  const { collections, importStatements, templateCode } = await generateCollections({
    pathToForestryConfig,
    usingTypescript,
    frontMatterFormat
  });
  const JSONString = JSON.stringify(collections, null, 2);
  const { code } = addVariablesToCode(JSONString);
  return {
    collectionString: code,
    importStatements,
    templateCodeString: templateCode
  };
};
var getFrontmatterFormat = async (rootPath) => {
  try {
    const hugoConfigPath = import_path11.default.join(rootPath, "config.toml");
    const hugoConfig = await import_fs_extra11.default.readFile(hugoConfigPath, "utf8");
    const frontMatterFormat = hugoConfig.match(/metaDataFormat = "(.*)"/);
    console.log({ frontMatterFormat });
    if (frontMatterFormat && frontMatterFormat[1]) {
      return frontMatterFormat[1];
    }
  } catch (e) {
  }
  const option = await (0, import_prompts2.default)({
    name: "selection",
    type: "select",
    choices: [
      { title: "yaml", value: "yaml" },
      { title: "toml", value: "toml" },
      { title: "json", value: "json" }
    ],
    message: `What format are you using in your frontmatter?`
  });
  if (!option["selection"]) {
    return null;
  }
  return option["selection"];
};
var reportTelemetry = async ({
  hasForestryConfig,
  noTelemetry,
  usingTypescript
}) => {
  if (noTelemetry) {
    logger.info(logText("Telemetry disabled"));
  }
  const telemetry = new import_metrics2.Telemetry({ disabled: noTelemetry });
  const schemaFileType = usingTypescript ? "ts" : "js";
  await telemetry.submitRecord({
    event: {
      name: "tinacms:cli:init:invoke",
      schemaFileType,
      hasForestryConfig
    }
  });
};
var createPackageJSON = async () => {
  logger.info(logText("No package.json found, creating one"));
  await execShellCommand(`npm init --yes`);
};
var createGitignore = async ({ baseDir }) => {
  logger.info(logText("No .gitignore found, creating one"));
  await import_fs_extra11.default.outputFileSync(import_path11.default.join(baseDir, ".gitignore"), "node_modules");
};
var checkGitignoreForNodeModules = async ({
  baseDir
}) => {
  const gitignoreContent = await import_fs_extra11.default.readFileSync(import_path11.default.join(baseDir, ".gitignore")).toString();
  return gitignoreContent.split("\n").some((item) => item === "node_modules");
};
var addNodeModulesToGitignore = async ({ baseDir }) => {
  logger.info(logText("Adding node_modules to .gitignore"));
  const gitignoreContent = await import_fs_extra11.default.readFileSync(import_path11.default.join(baseDir, ".gitignore")).toString();
  const newGitignoreContent = [
    ...gitignoreContent.split("\n"),
    "node_modules"
  ].join("\n");
  await import_fs_extra11.default.writeFileSync(import_path11.default.join(baseDir, ".gitignore"), newGitignoreContent);
};
var addDependencies = async (packageManager) => {
  logger.info(logText("Adding dependencies, this might take a moment..."));
  const deps = ["tinacms", "@tinacms/cli"];
  const packageManagers = {
    pnpm: process.env.USE_WORKSPACE ? `pnpm add ${deps.join(" ")} --workspace` : `pnpm add ${deps.join(" ")}`,
    npm: `npm install ${deps.join(" ")}`,
    yarn: `yarn add ${deps.join(" ")}`
  };
  logger.info(indentedCmd(`${logText(packageManagers[packageManager])}`));
  await execShellCommand(packageManagers[packageManager]);
};
var addConfigFile = async (args) => {
  const { baseDir, usingTypescript } = args;
  const configPath = import_path11.default.join(
    "tina",
    `config.${usingTypescript ? "ts" : "js"}`
  );
  const fullConfigPath = import_path11.default.join(baseDir, configPath);
  if (import_fs_extra11.default.pathExistsSync(fullConfigPath)) {
    const override = await (0, import_prompts2.default)({
      name: "selection",
      type: "confirm",
      message: `Found existing file at ${configPath}. Would you like to override?`
    });
    if (override["selection"]) {
      logger.info(logText(`Overriding file at ${configPath}.`));
      await import_fs_extra11.default.outputFileSync(fullConfigPath, config2(args));
    } else {
      logger.info(logText(`Not overriding file at ${configPath}.`));
    }
  } else {
    logger.info(
      logText(
        `Adding config file at tina/config.${usingTypescript ? "ts" : "js"}`
      )
    );
    await import_fs_extra11.default.outputFileSync(fullConfigPath, config2(args));
    await writeGitignore(baseDir);
  }
};
var addTemplateFile = async (args) => {
  const { baseDir, usingTypescript, templateCode } = args;
  const templatesPath = import_path11.default.join(
    "tina",
    `templates.${usingTypescript ? "ts" : "js"}`
  );
  const fullTemplatesPath = import_path11.default.join(baseDir, templatesPath);
  if (import_fs_extra11.default.pathExistsSync(fullTemplatesPath)) {
    const override = await (0, import_prompts2.default)({
      name: "selection",
      type: "confirm",
      message: `Found existing file at ${templatesPath}. Would you like to override?`
    });
    if (override["selection"]) {
      logger.info(logText(`Overriding file at ${templatesPath}.`));
      await import_fs_extra11.default.outputFileSync(fullTemplatesPath, templateCode);
    } else {
      logger.info(logText(`Not overriding file at ${templatesPath}.`));
    }
  } else {
    logger.info(logText(`Adding template file at ${templatesPath}`));
    await import_fs_extra11.default.outputFileSync(fullTemplatesPath, templateCode);
  }
};
var addContentFile = async ({ baseDir }) => {
  const contentPath = import_path11.default.join("content", "posts", "hello-world.md");
  const fullContentPath = import_path11.default.join(baseDir, contentPath);
  if (import_fs_extra11.default.pathExistsSync(fullContentPath)) {
    const override = await (0, import_prompts2.default)({
      name: "selection",
      type: "confirm",
      message: `Found existing file at ${contentPath}. Would you like to override?`
    });
    if (override["selection"]) {
      logger.info(logText(`Overriding file at ${contentPath}.`));
      await import_fs_extra11.default.outputFileSync(fullContentPath, content);
    } else {
      logger.info(logText(`Not overriding file at ${contentPath}.`));
    }
  } else {
    logger.info(logText(`Adding content file at ${contentPath}`));
    await import_fs_extra11.default.outputFileSync(fullContentPath, content);
  }
};
var logNextSteps = ({
  framework,
  packageManager
}) => {
  logger.info(focusText(`
${titleText(" TinaCMS ")} has been initialized!`));
  logger.info(
    "To get started run: " + cmdText(frameworkDevCmds[framework.name]({ packageManager }))
  );
  logger.info(
    `
Once your site is running, access the CMS at ${linkText(
      "<YourDevURL>/admin/index.html"
    )}`
  );
};
var other2 = ({ packageManager }) => {
  const packageManagers = {
    pnpm: `pnpm`,
    npm: `npx`,
    yarn: `yarn`
  };
  const installText = `${packageManagers[packageManager]} tinacms dev -c "<your dev command>"`;
  return installText;
};
var frameworkDevCmds = {
  other: other2,
  hugo: other2,
  jekyll: other2,
  next: ({ packageManager }) => {
    const packageManagers = {
      pnpm: `pnpm`,
      npm: `npm run`,
      yarn: `yarn`
    };
    const installText = `${packageManagers[packageManager]} dev`;
    return installText;
  }
};
var config2 = (args) => {
  return (0, import_prettier2.format)(configExamples[args.framework.name](args), { parser: "babel" });
};
var content = `---
title: Hello, World!
---

## Hello World!

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut non lorem diam. Quisque vulputate nibh sodales eros pretium tincidunt. Aenean porttitor efficitur convallis. Nulla sagittis finibus convallis. Phasellus in fermentum quam, eu egestas tortor. Maecenas ac mollis leo. Integer maximus eu nisl vel sagittis.

Suspendisse facilisis, mi ac scelerisque interdum, ligula ex imperdiet felis, a posuere eros justo nec sem. Nullam laoreet accumsan metus, sit amet tincidunt orci egestas nec. Pellentesque ut aliquet ante, at tristique nunc. Donec non massa nibh. Ut posuere lacus non aliquam laoreet. Fusce pharetra ligula a felis porttitor, at mollis ipsum maximus. Donec quam tortor, vehicula a magna sit amet, tincidunt dictum enim. In hac habitasse platea dictumst. Mauris sit amet ornare ligula, blandit consequat risus. Duis malesuada pellentesque lectus, non feugiat turpis eleifend a. Nullam tempus ante et diam pretium, ac faucibus ligula interdum.
`;
var addReactiveFile = {
  next: ({
    baseDir,
    usingTypescript
  }) => {
    const usingSrc = !import_fs_extra11.default.pathExistsSync(import_path11.default.join(baseDir, "pages"));
    const pagesPath = import_path11.default.join(baseDir, usingSrc ? "src" : "", "pages");
    const packageJSONPath = import_path11.default.join(baseDir, "package.json");
    const tinaBlogPagePath = import_path11.default.join(pagesPath, "demo", "blog");
    const tinaBlogPagePathFile = import_path11.default.join(
      tinaBlogPagePath,
      `[filename].${usingTypescript ? "tsx" : "js"}`
    );
    if (!import_fs_extra11.default.pathExistsSync(tinaBlogPagePathFile)) {
      import_fs_extra11.default.mkdirpSync(tinaBlogPagePath);
      import_fs_extra11.default.writeFileSync(tinaBlogPagePathFile, nextPostPage({ usingSrc }));
    }
    logger.info("Adding a nextjs example... \u2705");
    const pack = JSON.parse(import_fs_extra11.default.readFileSync(packageJSONPath).toString());
    const oldScripts = pack.scripts || {};
    const newPack = JSON.stringify(
      {
        ...pack,
        scripts: extendNextScripts(oldScripts)
      },
      null,
      2
    );
    import_fs_extra11.default.writeFileSync(packageJSONPath, newPack);
  }
};
function execShellCommand(cmd) {
  const exec = require("child_process").exec;
  return new Promise((resolve2, reject) => {
    exec(cmd, (error, stdout, stderr) => {
      if (error) {
        reject(error);
      }
      resolve2(stdout ? stdout : stderr);
    });
  });
}

// src/next/commands/init-command/index.ts
var InitCommand = class extends import_clipanion6.Command {
  constructor() {
    super(...arguments);
    this.pathToForestryConfig = import_clipanion6.Option.String("--forestryPath", {
      description: "Specify the relative path to the .forestry directory, if importing an existing forestry site."
    });
    this.rootPath = import_clipanion6.Option.String("--rootPath", {
      description: "Specify the root directory to run the CLI from (defaults to current working directory)"
    });
    this.noTelemetry = import_clipanion6.Option.Boolean("--noTelemetry", false, {
      description: "Disable anonymous telemetry that is collected"
    });
  }
  async catch(error) {
    logger.error("Error occured during tinacms init");
    console.error(error);
    process.exit(1);
  }
  async execute() {
    const rootPath = this.rootPath || process.cwd();
    await initStaticTina({
      rootPath,
      pathToForestryConfig: this.pathToForestryConfig || rootPath,
      noTelemetry: this.noTelemetry
    });
    process.exit();
  }
};
InitCommand.paths = [["init"]];
InitCommand.usage = import_clipanion6.Command.Usage({
  category: `Commands`,
  description: `Add Tina to an existing project`
});

// src/next/commands/searchindex-command/index.ts
var import_clipanion7 = require("clipanion");
var import_graphql16 = require("@tinacms/graphql");
var import_search3 = require("@tinacms/search");
var SearchIndexCommand = class extends import_clipanion7.Command {
  constructor() {
    super(...arguments);
    this.rootPath = import_clipanion7.Option.String("--rootPath", {
      description: "Specify the root directory to run the CLI from (defaults to current working directory)"
    });
    this.verbose = import_clipanion7.Option.Boolean("-v,--verbose", false, {
      description: "increase verbosity of logged output"
    });
  }
  async catch(error) {
    logger.error("Error occured during tinacms search-index");
    console.error(error);
    process.exit(1);
  }
  async execute() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u;
    const rootPath = this.rootPath || process.cwd();
    const configManager = new ConfigManager({ rootPath });
    try {
      await configManager.processConfig();
    } catch (e) {
      logger.error(e.message);
      if (this.verbose) {
        console.error(e);
      }
    }
    if (!((_a = configManager.config) == null ? void 0 : _a.search)) {
      logger.error("No search config found");
      process.exit(1);
    }
    const { schema } = configManager.config;
    const tinaSchema = await (0, import_graphql16.createSchema)({
      schema: { ...schema, config: configManager.config }
    });
    let client;
    const hasTinaSearch = Boolean((_c = (_b = configManager.config) == null ? void 0 : _b.search) == null ? void 0 : _c.tina);
    if (hasTinaSearch) {
      if (!((_d = configManager.config) == null ? void 0 : _d.branch)) {
        logger.error(
          `${dangerText(
            `ERROR: Branch not configured in tina search configuration.`
          )}`
        );
        throw new Error("Branch not configured in tina search configuration.");
      }
      if (!((_e = configManager.config) == null ? void 0 : _e.clientId)) {
        logger.error(`${dangerText(`ERROR: clientId not configured.`)}`);
        throw new Error("clientId not configured.");
      }
      if (!((_h = (_g = (_f = configManager.config) == null ? void 0 : _f.search) == null ? void 0 : _g.tina) == null ? void 0 : _h.indexerToken)) {
        logger.error(
          `${dangerText(
            `ERROR: indexerToken not configured in tina search configuration.`
          )}`
        );
        throw new Error(
          "indexerToken not configured in tina search configuration."
        );
      }
      client = new import_search3.TinaCMSSearchIndexClient({
        apiUrl: `${((_i = configManager.config.tinaioConfig) == null ? void 0 : _i.contentApiUrlOverride) || "https://content.tinajs.io"}/searchIndex/${(_j = configManager.config) == null ? void 0 : _j.clientId}`,
        branch: (_k = configManager.config) == null ? void 0 : _k.branch,
        indexerToken: (_n = (_m = (_l = configManager.config) == null ? void 0 : _l.search) == null ? void 0 : _m.tina) == null ? void 0 : _n.indexerToken,
        stopwordLanguages: (_q = (_p = (_o = configManager.config) == null ? void 0 : _o.search) == null ? void 0 : _p.tina) == null ? void 0 : _q.stopwordLanguages
      });
    } else {
      client = (_s = (_r = configManager.config) == null ? void 0 : _r.search) == null ? void 0 : _s.searchClient;
    }
    const searchIndexer = new import_search3.SearchIndexer({
      batchSize: ((_t = configManager.config.search) == null ? void 0 : _t.indexBatchSize) || 100,
      bridge: new import_graphql16.FilesystemBridge(
        configManager.rootPath,
        configManager.contentRootPath
      ),
      schema: tinaSchema,
      textIndexLength: ((_u = configManager.config.search) == null ? void 0 : _u.maxSearchIndexFieldLength) || 100,
      client
    });
    let err;
    await spin({
      waitFor: async () => {
        try {
          await searchIndexer.indexAllContent();
        } catch (e) {
          err = e;
        }
      },
      text: "Building search index"
    });
    if (err) {
      logger.error(`${dangerText(`ERROR: ${err.message}`)}`);
      process.exit(1);
    }
    process.exit(0);
  }
};
SearchIndexCommand.paths = [["search-index"]];
SearchIndexCommand.usage = import_clipanion7.Command.Usage({
  category: `Commands`,
  description: `Index the site for search`
});

// src/index.ts
var cli = new import_clipanion8.Cli({
  binaryName: `tinacms`,
  binaryLabel: `TinaCMS`,
  binaryVersion: version
});
cli.register(DevCommand);
cli.register(BuildCommand);
cli.register(AuditCommand);
cli.register(InitCommand);
cli.register(CodemodCommand);
cli.register(SearchIndexCommand);
cli.register(import_clipanion8.Builtins.DefinitionsCommand);
cli.register(import_clipanion8.Builtins.HelpCommand);
cli.register(import_clipanion8.Builtins.VersionCommand);
var src_default = cli;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
